import D from"/-/delaunator@v4.0.1-L2xxluDgUI2qTE5fQwYd/dist=es2020,mode=imports,min/optimized/delaunator.js";const V=1e-6;class b{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,t){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,t){this._+=`L${this._x1=+e},${this._y1=+t}`}arc(e,t,n){e=+e,t=+t,n=+n;const i=e+n,l=t;if(n<0)throw new Error("negative radius");if(this._x1===null?this._+=`M${i},${l}`:(Math.abs(this._x1-i)>V||Math.abs(this._y1-l)>V)&&(this._+="L"+i+","+l),!n)return;this._+=`A${n},${n},0,1,1,${e-n},${t}A${n},${n},0,1,1,${this._x1=i},${this._y1=l}`}rect(e,t,n,i){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}h${+n}v${+i}h${-n}Z`}value(){return this._||null}}class S{constructor(){this._=[]}moveTo(e,t){this._.push([e,t])}closePath(){this._.push(this._[0].slice())}lineTo(e,t){this._.push([e,t])}value(){return this._.length?this._:null}}class Y{constructor(e,[t,n,i,l]=[0,0,960,500]){if(!((i=+i)>=(t=+t))||!((l=+l)>=(n=+n)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=i,this.xmin=t,this.ymax=l,this.ymin=n,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:t,triangles:n},vectors:i}=this,l=this.circumcenters=this._circumcenters.subarray(0,n.length/3*2);for(let a=0,g=0,_=n.length,m,p;a<_;a+=3,g+=2){const y=n[a]*2,E=n[a+1]*2,H=n[a+2]*2,w=e[y],v=e[y+1],Z=e[E],q=e[E+1],M=e[H],A=e[H+1],I=Z-w,j=q-v,T=M-w,$=A-v,L=I*I+j*j,P=T*T+$*$,k=(I*$-j*T)*2;if(!k)m=(w+M)/2-1e8*$,p=(v+A)/2+1e8*T;else if(Math.abs(k)<1e-8)m=(w+M)/2,p=(v+A)/2;else{const C=1/k;m=w+($*L-j*P)*C,p=v+(I*P-T*L)*C}l[g]=m,l[g+1]=p}let s=t[t.length-1],h,r=s*4,o,u=e[2*s],f,c=e[2*s+1];i.fill(0);for(let a=0;a<t.length;++a)s=t[a],h=r,o=u,f=c,r=s*4,u=e[2*s],c=e[2*s+1],i[h+2]=i[r]=f-c,i[h+3]=i[r+1]=u-o}render(e){const t=e==null?e=new b:void 0,{delaunay:{halfedges:n,inedges:i,hull:l},circumcenters:s,vectors:h}=this;if(l.length<=1)return null;for(let u=0,f=n.length;u<f;++u){const c=n[u];if(c<u)continue;const a=Math.floor(u/3)*2,g=Math.floor(c/3)*2,_=s[a],m=s[a+1],p=s[g],y=s[g+1];this._renderSegment(_,m,p,y,e)}let r,o=l[l.length-1];for(let u=0;u<l.length;++u){r=o,o=l[u];const f=Math.floor(i[o]/3)*2,c=s[f],a=s[f+1],g=r*4,_=this._project(c,a,h[g+2],h[g+3]);_&&this._renderSegment(c,a,_[0],_[1],e)}return t&&t.value()}renderBounds(e){const t=e==null?e=new b:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),t&&t.value()}renderCell(e,t){const n=t==null?t=new b:void 0,i=this._clip(e);if(i===null||!i.length)return;t.moveTo(i[0],i[1]);let l=i.length;for(;i[0]===i[l-2]&&i[1]===i[l-1]&&l>1;)l-=2;for(let s=2;s<l;s+=2)(i[s]!==i[s-2]||i[s+1]!==i[s-1])&&t.lineTo(i[s],i[s+1]);return t.closePath(),n&&n.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let t=0,n=e.length/2;t<n;++t){const i=this.cellPolygon(t);i&&(i.index=t,yield i)}}cellPolygon(e){const t=new S;return this.renderCell(e,t),t.value()}_renderSegment(e,t,n,i,l){let s;const h=this._regioncode(e,t),r=this._regioncode(n,i);h===0&&r===0?(l.moveTo(e,t),l.lineTo(n,i)):(s=this._clipSegment(e,t,n,i,h,r))&&(l.moveTo(s[0],s[1]),l.lineTo(s[2],s[3]))}contains(e,t,n){return(t=+t,t!==t)||(n=+n,n!==n)?!1:this.delaunay._step(e,t,n)===e}*neighbors(e){const t=this._clip(e);if(t)for(const n of this.delaunay.neighbors(e)){const i=this._clip(n);if(i)t:for(let l=0,s=t.length;l<s;l+=2)for(let h=0,r=i.length;h<r;h+=2)if(t[l]==i[h]&&t[l+1]==i[h+1]&&t[(l+2)%s]==i[(h+r-2)%r]&&t[(l+3)%s]==i[(h+r-1)%r]){yield n;break t}}}_cell(e){const{circumcenters:t,delaunay:{inedges:n,halfedges:i,triangles:l}}=this,s=n[e];if(s===-1)return null;const h=[];let r=s;do{const o=Math.floor(r/3);if(h.push(t[o*2],t[o*2+1]),r=r%3===2?r-2:r+1,l[r]!==e)break;r=i[r]}while(r!==s&&r!==-1);return h}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const t=this._cell(e);if(t===null)return null;const{vectors:n}=this,i=e*4;return n[i]||n[i+1]?this._clipInfinite(e,t,n[i],n[i+1],n[i+2],n[i+3]):this._clipFinite(e,t)}_clipFinite(e,t){const n=t.length;let i=null,l,s,h=t[n-2],r=t[n-1],o,u=this._regioncode(h,r),f,c;for(let a=0;a<n;a+=2)if(l=h,s=r,h=t[a],r=t[a+1],o=u,u=this._regioncode(h,r),o===0&&u===0)f=c,c=0,i?i.push(h,r):i=[h,r];else{let g,_,m,p,y;if(o===0){if((g=this._clipSegment(l,s,h,r,o,u))===null)continue;[_,m,p,y]=g}else{if((g=this._clipSegment(h,r,l,s,u,o))===null)continue;[p,y,_,m]=g,f=c,c=this._edgecode(_,m),f&&c&&this._edge(e,f,c,i,i.length),i?i.push(_,m):i=[_,m]}f=c,c=this._edgecode(p,y),f&&c&&this._edge(e,f,c,i,i.length),i?i.push(p,y):i=[p,y]}if(i)f=c,c=this._edgecode(i[0],i[1]),f&&c&&this._edge(e,f,c,i,i.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return i}_clipSegment(e,t,n,i,l,s){for(;;){if(l===0&&s===0)return[e,t,n,i];if(l&s)return null;let h,r,o=l||s;o&8?(h=e+(n-e)*(this.ymax-t)/(i-t),r=this.ymax):o&4?(h=e+(n-e)*(this.ymin-t)/(i-t),r=this.ymin):o&2?(r=t+(i-t)*(this.xmax-e)/(n-e),h=this.xmax):(r=t+(i-t)*(this.xmin-e)/(n-e),h=this.xmin),l?(e=h,t=r,l=this._regioncode(e,t)):(n=h,i=r,s=this._regioncode(n,i))}}_clipInfinite(e,t,n,i,l,s){let h=Array.from(t),r;if((r=this._project(h[0],h[1],n,i))&&h.unshift(r[0],r[1]),(r=this._project(h[h.length-2],h[h.length-1],l,s))&&h.push(r[0],r[1]),h=this._clipFinite(e,h))for(let o=0,u=h.length,f,c=this._edgecode(h[u-2],h[u-1]);o<u;o+=2)f=c,c=this._edgecode(h[o],h[o+1]),f&&c&&(o=this._edge(e,f,c,h,o),u=h.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(h=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return h}_edge(e,t,n,i,l){for(;t!==n;){let s,h;switch(t){case 5:t=4;continue;case 4:t=6,s=this.xmax,h=this.ymin;break;case 6:t=2;continue;case 2:t=10,s=this.xmax,h=this.ymax;break;case 10:t=8;continue;case 8:t=9,s=this.xmin,h=this.ymax;break;case 9:t=1;continue;case 1:t=5,s=this.xmin,h=this.ymin;break}(i[l]!==s||i[l+1]!==h)&&this.contains(e,s,h)&&(i.splice(l,0,s,h),l+=2)}if(i.length>4)for(let s=0;s<i.length;s+=2){const h=(s+2)%i.length,r=(s+4)%i.length;(i[s]===i[h]&&i[h]===i[r]||i[s+1]===i[h+1]&&i[h+1]===i[r+1])&&(i.splice(h,2),s-=2)}return l}_project(e,t,n,i){let l=Infinity,s,h,r;if(i<0){if(t<=this.ymin)return null;(s=(this.ymin-t)/i)<l&&(r=this.ymin,h=e+(l=s)*n)}else if(i>0){if(t>=this.ymax)return null;(s=(this.ymax-t)/i)<l&&(r=this.ymax,h=e+(l=s)*n)}if(n>0){if(e>=this.xmax)return null;(s=(this.xmax-e)/n)<l&&(h=this.xmax,r=t+(l=s)*i)}else if(n<0){if(e<=this.xmin)return null;(s=(this.xmin-e)/n)<l&&(h=this.xmin,r=t+(l=s)*i)}return[h,r]}_edgecode(e,t){return(e===this.xmin?1:e===this.xmax?2:0)|(t===this.ymin?4:t===this.ymax?8:0)}_regioncode(e,t){return(e<this.xmin?1:e>this.xmax?2:0)|(t<this.ymin?4:t>this.ymax?8:0)}}const z=2*Math.PI,x=Math.pow;function B(d){return d[0]}function O(d){return d[1]}function Q(d){const{triangles:e,coords:t}=d;for(let n=0;n<e.length;n+=3){const i=2*e[n],l=2*e[n+1],s=2*e[n+2],h=(t[s]-t[i])*(t[l+1]-t[i+1])-(t[l]-t[i])*(t[s+1]-t[i+1]);if(h>1e-10)return!1}return!0}function U(d,e,t){return[d+Math.sin(d+e)*t,e+Math.cos(d-e)*t]}class F{static from(e,t=B,n=O,i){return new F("length"in e?X(e,t,n,i):Float64Array.from(G(e,t,n,i)))}constructor(e){this._delaunator=new D(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,t=this.points;if(e.hull&&e.hull.length>2&&Q(e)){this.collinear=Int32Array.from({length:t.length/2},(c,a)=>a).sort((c,a)=>t[2*c]-t[2*a]||t[2*c+1]-t[2*a+1]);const r=this.collinear[0],o=this.collinear[this.collinear.length-1],u=[t[2*r],t[2*r+1],t[2*o],t[2*o+1]],f=1e-8*Math.hypot(u[3]-u[1],u[2]-u[0]);for(let c=0,a=t.length/2;c<a;++c){const g=U(t[2*c],t[2*c+1],f);t[2*c]=g[0],t[2*c+1]=g[1]}this._delaunator=new D(t)}else delete this.collinear;const n=this.halfedges=this._delaunator.halfedges,i=this.hull=this._delaunator.hull,l=this.triangles=this._delaunator.triangles,s=this.inedges.fill(-1),h=this._hullIndex.fill(-1);for(let r=0,o=n.length;r<o;++r){const u=l[r%3===2?r-2:r+1];(n[r]===-1||s[u]===-1)&&(s[u]=r)}for(let r=0,o=i.length;r<o;++r)h[i[r]]=r;i.length<=2&&i.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=i[0],this.triangles[1]=i[1],this.triangles[2]=i[1],s[i[0]]=1,i.length===2&&(s[i[1]]=0))}voronoi(e){return new Y(this,e)}*neighbors(e){const{inedges:t,hull:n,_hullIndex:i,halfedges:l,triangles:s,collinear:h}=this;if(h){const f=h.indexOf(e);f>0&&(yield h[f-1]),f<h.length-1&&(yield h[f+1]);return}const r=t[e];if(r===-1)return;let o=r,u=-1;do{if(yield u=s[o],o=o%3===2?o-2:o+1,s[o]!==e)return;if(o=l[o],o===-1){const f=n[(i[e]+1)%n.length];f!==u&&(yield f);return}}while(o!==r)}find(e,t,n=0){if((e=+e,e!==e)||(t=+t,t!==t))return-1;const i=n;let l;for(;(l=this._step(n,e,t))>=0&&l!==n&&l!==i;)n=l;return l}_step(e,t,n){const{inedges:i,hull:l,_hullIndex:s,halfedges:h,triangles:r,points:o}=this;if(i[e]===-1||!o.length)return(e+1)%(o.length>>1);let u=e,f=x(t-o[e*2],2)+x(n-o[e*2+1],2);const c=i[e];let a=c;do{let g=r[a];const _=x(t-o[g*2],2)+x(n-o[g*2+1],2);if(_<f&&(f=_,u=g),a=a%3===2?a-2:a+1,r[a]!==e)break;if(a=h[a],a===-1){if(a=l[(s[e]+1)%l.length],a!==g&&x(t-o[a*2],2)+x(n-o[a*2+1],2)<f)return a;break}}while(a!==c);return u}render(e){const t=e==null?e=new b:void 0,{points:n,halfedges:i,triangles:l}=this;for(let s=0,h=i.length;s<h;++s){const r=i[s];if(r<s)continue;const o=l[s]*2,u=l[r]*2;e.moveTo(n[o],n[o+1]),e.lineTo(n[u],n[u+1])}return this.renderHull(e),t&&t.value()}renderPoints(e,t=2){const n=e==null?e=new b:void 0,{points:i}=this;for(let l=0,s=i.length;l<s;l+=2){const h=i[l],r=i[l+1];e.moveTo(h+t,r),e.arc(h,r,t,0,z)}return n&&n.value()}renderHull(e){const t=e==null?e=new b:void 0,{hull:n,points:i}=this,l=n[0]*2,s=n.length;e.moveTo(i[l],i[l+1]);for(let h=1;h<s;++h){const r=2*n[h];e.lineTo(i[r],i[r+1])}return e.closePath(),t&&t.value()}hullPolygon(){const e=new S;return this.renderHull(e),e.value()}renderTriangle(e,t){const n=t==null?t=new b:void 0,{points:i,triangles:l}=this,s=l[e*=3]*2,h=l[e+1]*2,r=l[e+2]*2;return t.moveTo(i[s],i[s+1]),t.lineTo(i[h],i[h+1]),t.lineTo(i[r],i[r+1]),t.closePath(),n&&n.value()}*trianglePolygons(){const{triangles:e}=this;for(let t=0,n=e.length/3;t<n;++t)yield this.trianglePolygon(t)}trianglePolygon(e){const t=new S;return this.renderTriangle(e,t),t.value()}}function X(d,e,t,n){const i=d.length,l=new Float64Array(i*2);for(let s=0;s<i;++s){const h=d[s];l[s*2]=e.call(n,h,s,d),l[s*2+1]=t.call(n,h,s,d)}return l}function*G(d,e,t,n){let i=0;for(const l of d)yield e.call(n,l,i,d),yield t.call(n,l,i,d),++i}export{F as Delaunay,Y as Voronoi};export default null;
