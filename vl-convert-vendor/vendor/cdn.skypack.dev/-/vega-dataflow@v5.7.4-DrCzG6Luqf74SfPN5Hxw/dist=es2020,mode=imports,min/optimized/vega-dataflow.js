import{array as b,isFunction as E,constant as K,isArray as O,error as R,truthy as $,identity as X,debounce as mt,visitArray as A,inherits as x,logger as gt,Error as _t,hasOwnProperty as vt,id as C,extend as wt}from"/-/vega-util@v1.17.0-uRskU0IBL2vWCP4Va8OC/dist=es2020,mode=imports,min/optimized/vega-util.js";import{loader as kt,read as Ft,responseType as yt}from"/-/vega-loader@v4.4.1-g6OZb9mGT1iFgFNYp8zS/dist=es2020,mode=imports,min/optimized/vega-loader.js";import{defaultLocale as Dt}from"/-/vega-format@v1.0.4-1uFKb12DsLjjrCjIDOQK/dist=es2020,mode=imports,min/optimized/vega-format.js";function q(t){const e=t||X,n=[],i={};return n.add=s=>{const r=e(s);return i[r]||(i[r]=1,n.push(s)),n},n.remove=s=>{const r=e(s);if(i[r]){i[r]=0;const u=n.indexOf(s);u>=0&&n.splice(u,1)}return n},n}async function I(t,e){try{await e(t)}catch(n){t.error(n)}}const tt=Symbol("vega_id");let Pt=1;function Et(t){return!!(t&&d(t))}function d(t){return t[tt]}function et(t,e){return t[tt]=e,t}function H(t){const e=t===Object(t)?t:{data:t};return d(e)?e:et(e,Pt++)}function Ot(t){return nt(t,H({}))}function nt(t,e){for(const n in t)e[n]=t[n];return e}function At(t,e){return et(e,d(t))}function St(t,e){return t?e?(n,i)=>t(n,i)||d(e(n))-d(e(i)):(n,i)=>t(n,i)||d(n)-d(i):null}function it(t){return t&&t.constructor===z}function z(){const t=[],e=[],n=[],i=[],s=[];let r=null,u=!1;return{constructor:z,insert(o){const h=b(o),a=h.length;for(let f=0;f<a;++f)t.push(h[f]);return this},remove(o){const h=E(o)?i:e,a=b(o),f=a.length;for(let l=0;l<f;++l)h.push(a[l]);return this},modify(o,h,a){const f={field:h,value:K(a)};return E(o)?(f.filter=o,s.push(f)):(f.tuple=o,n.push(f)),this},encode(o,h){return E(o)?s.push({filter:o,field:h}):n.push({tuple:o,field:h}),this},clean(o){return r=o,this},reflow(){return u=!0,this},pulse(o,h){const a={},f={};let l,c,p,D,_,P;for(l=0,c=h.length;l<c;++l)a[d(h[l])]=1;for(l=0,c=e.length;l<c;++l)_=e[l],a[d(_)]=-1;for(l=0,c=i.length;l<c;++l)D=i[l],h.forEach(m=>{D(m)&&(a[d(m)]=-1)});for(l=0,c=t.length;l<c;++l)_=t[l],P=d(_),a[P]?a[P]=1:o.add.push(H(t[l]));for(l=0,c=h.length;l<c;++l)_=h[l],a[d(_)]<0&&o.rem.push(_);function V(m,Z,J){J?m[Z]=J(m):o.encode=Z,u||(f[d(m)]=m)}for(l=0,c=n.length;l<c;++l)p=n[l],_=p.tuple,D=p.field,P=a[d(_)],P>0&&(V(_,D,p.value),o.modifies(D));for(l=0,c=s.length;l<c;++l)p=s[l],D=p.filter,h.forEach(m=>{D(m)&&a[d(m)]>0&&V(m,p.field,p.value)}),o.modifies(p.field);if(u)o.mod=e.length||i.length?h.filter(m=>a[d(m)]>0):h.slice();else for(P in f)o.mod.push(f[P]);return(r||r==null&&(e.length||i.length))&&o.clean(!0),o}}}const T="_:mod:_";function U(){Object.defineProperty(this,T,{writable:!0,value:{}})}U.prototype={set(t,e,n,i){const s=this,r=s[t],u=s[T];return e!=null&&e>=0?(r[e]!==n||i)&&(r[e]=n,u[e+":"+t]=-1,u[t]=-1):(r!==n||i)&&(s[t]=n,u[t]=O(n)?1+n.length:-1),s},modified(t,e){const n=this[T];if(arguments.length){if(O(t)){for(let i=0;i<t.length;++i)if(n[t[i]])return!0;return!1}}else{for(const i in n)if(n[i])return!0;return!1}return e!=null&&e>=0?e+1<n[t]||!!n[e+":"+t]:!!n[t]},clear(){return this[T]={},this}};let qt=0;const Mt="pulse",Lt=new U,bt=1,Rt=2;function g(t,e,n,i){this.id=++qt,this.value=t,this.stamp=-1,this.rank=-1,this.qrank=-1,this.flags=0,e&&(this._update=e),n&&this.parameters(n,i)}function st(t){return function(e){const n=this.flags;return arguments.length===0?!!(n&t):(this.flags=e?n|t:n&~t,this)}}g.prototype={targets(){return this._targets||(this._targets=q(C))},set(t){return this.value!==t?(this.value=t,1):0},skip:st(bt),modified:st(Rt),parameters(t,e,n){e=e!==!1;const i=this._argval=this._argval||new U,s=this._argops=this._argops||[],r=[];let u,o,h,a;const f=(l,c,p)=>{p instanceof g?(p!==this&&(e&&p.targets().add(this),r.push(p)),s.push({op:p,name:l,index:c})):i.set(l,c,p)};for(u in t)if(o=t[u],u===Mt)b(o).forEach(l=>{l instanceof g?l!==this&&(l.targets().add(this),r.push(l)):R("Pulse parameters must be operator instances.")}),this.source=o;else if(O(o))for(i.set(u,-1,Array(h=o.length)),a=0;a<h;++a)f(u,a,o[a]);else f(u,-1,o);return this.marshall().clear(),n&&(s.initonly=!0),r},marshall(t){const e=this._argval||Lt,n=this._argops;let i,s,r,u;if(n){const o=n.length;for(s=0;s<o;++s)i=n[s],r=i.op,u=r.modified()&&r.stamp===t,e.set(i.name,i.index,r.value,u);if(n.initonly){for(s=0;s<o;++s)i=n[s],i.op.targets().remove(this);this._argops=null,this._update=null}}return e},detach(){const t=this._argops;let e,n,i,s;if(t)for(e=0,n=t.length;e<n;++e)i=t[e],s=i.op,s._targets&&s._targets.remove(this);this.pulse=null,this.source=null},evaluate(t){const e=this._update;if(e){const n=this.marshall(t.stamp),i=e.call(this,n,t);if(n.clear(),i!==this.value)this.value=i;else if(!this.modified())return t.StopPropagation}},run(t){if(t.stamp<this.stamp)return t.StopPropagation;let e;return this.skip()?(this.skip(!1),e=0):e=this.evaluate(t),this.pulse=e||t}};function Ct(t,e,n,i){let s=1,r;return t instanceof g?r=t:t&&t.prototype instanceof g?r=new t:E(t)?r=new g(null,t):(s=0,r=new g(t,e)),this.rank(r),s&&(i=n,n=e),n&&this.connect(r,r.parameters(n,i)),this.touch(r),r}function It(t,e){const n=t.rank,i=e.length;for(let s=0;s<i;++s)if(n<e[s].rank){this.rerank(t);return}}let zt=0;function W(t,e,n){this.id=++zt,this.value=null,n&&(this.receive=n),t&&(this._filter=t),e&&(this._apply=e)}function k(t,e,n){return new W(t,e,n)}W.prototype={_filter:$,_apply:X,targets(){return this._targets||(this._targets=q(C))},consume(t){return arguments.length?(this._consume=!!t,this):!!this._consume},receive(t){if(this._filter(t)){const e=this.value=this._apply(t),n=this._targets,i=n?n.length:0;for(let s=0;s<i;++s)n[s].receive(e);this._consume&&(t.preventDefault(),t.stopPropagation())}},filter(t){const e=k(t);return this.targets().add(e),e},apply(t){const e=k(null,t);return this.targets().add(e),e},merge(){const t=k();this.targets().add(t);for(let e=0,n=arguments.length;e<n;++e)arguments[e].targets().add(t);return t},throttle(t){let e=-1;return this.filter(()=>{const n=Date.now();return n-e>t?(e=n,1):0})},debounce(t){const e=k();return this.targets().add(k(null,null,mt(t,n=>{const i=n.dataflow;e.receive(n),i&&i.run&&i.run()}))),e},between(t,e){let n=!1;return t.targets().add(k(null,null,()=>n=!0)),e.targets().add(k(null,null,()=>n=!1)),this.filter(()=>n)},detach(){this._filter=$,this._targets=null}};function Tt(t,e,n,i){const s=this,r=k(n,i),u=function(a){a.dataflow=s;try{r.receive(a)}catch(f){s.error(f)}finally{s.run()}};let o;typeof t=="string"&&typeof document!="undefined"?o=document.querySelectorAll(t):o=b(t);const h=o.length;for(let a=0;a<h;++a)o[a].addEventListener(e,u);return r}function Ut(t,e){const n=this.locale();return Ft(t,e,n.timeParse,n.utcParse)}function jt(t,e,n){return e=this.parse(e,n),this.pulse(t,this.changeset().insert(e))}async function Nt(t,e){const n=this;let i=0,s;try{s=await n.loader().load(t,{context:"dataflow",response:yt(e&&e.type)});try{s=n.parse(s,e)}catch(r){i=-2,n.warn("Data ingestion failed",t,r)}}catch(r){i=-1,n.warn("Loading failed",t,r)}return{data:s,status:i}}async function Kt(t,e,n){const i=this,s=i._pending||$t(i);s.requests+=1;const r=await i.request(e,n);return i.pulse(t,i.changeset().remove($).insert(r.data||[])),s.done(),r}function $t(t){let e;const n=new Promise(i=>e=i);return n.requests=0,n.done=()=>{--n.requests===0&&(t._pending=null,e(t))},t._pending=n}const Ht={skip:!0};function Wt(t,e,n,i,s){const r=t instanceof g?Bt:Yt;return r(this,t,e,n,i,s),this}function Yt(t,e,n,i,s,r){const u=wt({},r,Ht);let o,h;E(n)||(n=K(n)),i===void 0?o=a=>t.touch(n(a)):E(i)?(h=new g(null,i,s,!1),o=a=>{h.evaluate(a);const f=n(a),l=h.value;it(l)?t.pulse(f,l,r):t.update(f,l,u)}):o=a=>t.update(n(a),i,u),e.apply(o)}function Bt(t,e,n,i,s,r){if(i===void 0)e.targets().add(n);else{const u=r||{},o=new g(null,Gt(n,i),s,!1);o.modified(u.force),o.rank=e.rank,e.targets().add(o),n&&(o.skip(!0),o.value=n.value,o.targets().add(n),t.connect(n,[o]))}}function Gt(t,e){return e=E(e)?e:K(e),t?function(n,i){const s=e(n,i);return t.skip()||(t.skip(s!==this.value).value=s),s}:e}function Qt(t){t.rank=++this._rank}function Vt(t){const e=[t];let n,i,s;for(;e.length;)if(this.rank(n=e.pop()),i=n._targets)for(s=i.length;--s>=0;)e.push(n=i[s]),n===t&&R("Cycle detected in dataflow graph.")}const j={},v=1<<0,F=1<<1,w=1<<2,Zt=v|F,rt=v|w,S=v|F|w,ot=1<<3,M=1<<4,lt=1<<5,ut=1<<6;function y(t,e,n){this.dataflow=t,this.stamp=e??-1,this.add=[],this.rem=[],this.mod=[],this.fields=null,this.encode=n||null}function Y(t,e){const n=[];return A(t,e,i=>n.push(i)),n}function ht(t,e){const n={};return t.visit(e,i=>{n[d(i)]=1}),i=>n[d(i)]?null:i}function N(t,e){return t?(n,i)=>t(n,i)&&e(n,i):e}y.prototype={StopPropagation:j,ADD:v,REM:F,MOD:w,ADD_REM:Zt,ADD_MOD:rt,ALL:S,REFLOW:ot,SOURCE:M,NO_SOURCE:lt,NO_FIELDS:ut,fork(t){return new y(this.dataflow).init(this,t)},clone(){const t=this.fork(S);return t.add=t.add.slice(),t.rem=t.rem.slice(),t.mod=t.mod.slice(),t.source&&(t.source=t.source.slice()),t.materialize(S|M)},addAll(){let t=this;const e=!t.source||t.add===t.rem||!t.rem.length&&t.source.length===t.add.length;return e||(t=new y(this.dataflow).init(this),t.add=t.source,t.rem=[]),t},init(t,e){const n=this;return n.stamp=t.stamp,n.encode=t.encode,t.fields&&!(e&ut)&&(n.fields=t.fields),e&v?(n.addF=t.addF,n.add=t.add):(n.addF=null,n.add=[]),e&F?(n.remF=t.remF,n.rem=t.rem):(n.remF=null,n.rem=[]),e&w?(n.modF=t.modF,n.mod=t.mod):(n.modF=null,n.mod=[]),e&lt?(n.srcF=null,n.source=null):(n.srcF=t.srcF,n.source=t.source,t.cleans&&(n.cleans=t.cleans)),n},runAfter(t){this.dataflow.runAfter(t)},changed(t){const e=t||S;return e&v&&this.add.length||e&F&&this.rem.length||e&w&&this.mod.length},reflow(t){if(t)return this.fork(S).reflow();const e=this.add.length,n=this.source&&this.source.length;return n&&n!==e&&(this.mod=this.source,e&&this.filter(w,ht(this,v))),this},clean(t){return arguments.length?(this.cleans=!!t,this):this.cleans},modifies(t){const e=this.fields||(this.fields={});return O(t)?t.forEach(n=>e[n]=!0):e[t]=!0,this},modified(t,e){const n=this.fields;return(e||this.mod.length)&&n?arguments.length?O(t)?t.some(i=>n[i]):n[t]:!!n:!1},filter(t,e){const n=this;return t&v&&(n.addF=N(n.addF,e)),t&F&&(n.remF=N(n.remF,e)),t&w&&(n.modF=N(n.modF,e)),t&M&&(n.srcF=N(n.srcF,e)),n},materialize(t){t=t||S;const e=this;return t&v&&e.addF&&(e.add=Y(e.add,e.addF),e.addF=null),t&F&&e.remF&&(e.rem=Y(e.rem,e.remF),e.remF=null),t&w&&e.modF&&(e.mod=Y(e.mod,e.modF),e.modF=null),t&M&&e.srcF&&(e.source=e.source.filter(e.srcF),e.srcF=null),e},visit(t,e){const n=this,i=e;if(t&M)return A(n.source,n.srcF,i),n;t&v&&A(n.add,n.addF,i),t&F&&A(n.rem,n.remF,i),t&w&&A(n.mod,n.modF,i);const s=n.source;if(t&ot&&s){const r=n.add.length+n.mod.length;r===s.length||(r?A(s,ht(n,rt),i):A(s,n.srcF,i))}return n}};function B(t,e,n,i){const s=this,r=n.length;let u=0;this.dataflow=t,this.stamp=e,this.fields=null,this.encode=i||null,this.pulses=n;for(let o=0;o<r;++o){const h=n[o];if(h.stamp!==e)continue;if(h.fields){const a=s.fields||(s.fields={});for(const f in h.fields)a[f]=1}h.changed(s.ADD)&&(u|=s.ADD),h.changed(s.REM)&&(u|=s.REM),h.changed(s.MOD)&&(u|=s.MOD)}this.changes=u}x(B,y,{fork(t){const e=new y(this.dataflow).init(this,t&this.NO_FIELDS);return t!==void 0&&(t&e.ADD&&this.visit(e.ADD,n=>e.add.push(n)),t&e.REM&&this.visit(e.REM,n=>e.rem.push(n)),t&e.MOD&&this.visit(e.MOD,n=>e.mod.push(n))),e},changed(t){return this.changes&t},modified(t){const e=this,n=e.fields;return n&&e.changes&e.MOD?O(t)?t.some(i=>n[i]):n[t]:0},filter(){R("MultiPulse does not support filtering.")},materialize(){R("MultiPulse does not support materialization.")},visit(t,e){const n=this,i=n.pulses,s=i.length;let r=0;if(t&n.SOURCE)for(;r<s;++r)i[r].visit(t,e);else for(;r<s;++r)i[r].stamp===n.stamp&&i[r].visit(t,e);return n}});async function Jt(t,e,n){const i=this,s=[];if(i._pulse)return at(i);if(i._pending&&await i._pending,e&&await I(i,e),!i._touched.length)return i.debug("Dataflow invoked, but nothing to do."),i;const r=++i._clock;i._pulse=new y(i,r,t),i._touched.forEach(f=>i._enqueue(f,!0)),i._touched=q(C);let u=0,o,h,a;try{for(;i._heap.size()>0;){if(o=i._heap.pop(),o.rank!==o.qrank){i._enqueue(o,!0);continue}h=o.run(i._getPulse(o,t)),h.then?h=await h:h.async&&(s.push(h.async),h=j),h!==j&&(o._targets&&o._targets.forEach(f=>i._enqueue(f))),++u}}catch(f){i._heap.clear(),a=f}if(i._input={},i._pulse=null,i.debug(`Pulse ${r}: ${u} operators`),a&&(i._postrun=[],i.error(a)),i._postrun.length){const f=i._postrun.sort((l,c)=>c.priority-l.priority);i._postrun=[];for(let l=0;l<f.length;++l)await I(i,f[l].callback)}return n&&await I(i,n),s.length&&Promise.all(s).then(f=>i.runAsync(null,()=>{f.forEach(l=>{try{l(i)}catch(c){i.error(c)}})})),i}async function Xt(t,e,n){for(;this._running;)await this._running;const i=()=>this._running=null;return(this._running=this.evaluate(t,e,n)).then(i,i),this._running}function xt(t,e,n){return this._pulse?at(this):(this.evaluate(t,e,n),this)}function te(t,e,n){if(this._pulse||e)this._postrun.push({priority:n||0,callback:t});else try{t(this)}catch(i){this.error(i)}}function at(t){return t.error("Dataflow already running. Use runAsync() to chain invocations."),t}function ee(t,e){const n=t.stamp<this._clock;n&&(t.stamp=this._clock),(n||e)&&(t.qrank=t.rank,this._heap.push(t))}function ne(t,e){const n=t.source,i=this._clock;return n&&O(n)?new B(this,i,n.map(s=>s.pulse),e):this._input[t.id]||ie(this._pulse,n&&n.pulse)}function ie(t,e){return e&&e.stamp===t.stamp?e:(t=t.fork(),e&&e!==j&&(t.source=e.source),t)}const G={skip:!1,force:!1};function se(t,e){const n=e||G;return this._pulse?this._enqueue(t):this._touched.add(t),n.skip&&t.skip(!0),this}function re(t,e,n){const i=n||G;return(t.set(e)||i.force)&&this.touch(t,i),this}function oe(t,e,n){this.touch(t,n||G);const i=new y(this,this._clock+(this._pulse?0:1)),s=t.pulse&&t.pulse.source||[];return i.target=t,this._input[t.id]=e.pulse(i,s),this}function le(t){let e=[];return{clear:()=>e=[],size:()=>e.length,peek:()=>e[0],push:n=>(e.push(n),ft(e,0,e.length-1,t)),pop:()=>{const n=e.pop();let i;return e.length?(i=e[0],e[0]=n,ue(e,0,t)):i=n,i}}}function ft(t,e,n,i){let s,r;const u=t[n];for(;n>e;){if(r=n-1>>1,s=t[r],i(u,s)<0){t[n]=s,n=r;continue}break}return t[n]=u}function ue(t,e,n){const i=e,s=t.length,r=t[e];let u=(e<<1)+1,o;for(;u<s;)o=u+1,o<s&&n(t[u],t[o])>=0&&(u=o),t[e]=t[u],e=u,u=(e<<1)+1;return t[e]=r,ft(t,i,e,n)}function ct(){this.logger(gt()),this.logLevel(_t),this._clock=0,this._rank=0,this._locale=Dt();try{this._loader=kt()}catch(t){}this._touched=q(C),this._input={},this._pulse=null,this._heap=le((t,e)=>t.qrank-e.qrank),this._postrun=[]}function L(t){return function(){return this._log[t].apply(this,arguments)}}ct.prototype={stamp(){return this._clock},loader(t){return arguments.length?(this._loader=t,this):this._loader},locale(t){return arguments.length?(this._locale=t,this):this._locale},logger(t){return arguments.length?(this._log=t,this):this._log},error:L("error"),warn:L("warn"),info:L("info"),debug:L("debug"),logLevel:L("level"),cleanThreshold:1e4,add:Ct,connect:It,rank:Qt,rerank:Vt,pulse:oe,touch:se,update:re,changeset:z,ingest:jt,parse:Ut,preload:Kt,request:Nt,events:Tt,on:Wt,evaluate:Jt,run:xt,runAsync:Xt,runAfter:te,_enqueue:ee,_getPulse:ne};function dt(t,e){g.call(this,t,null,e)}x(dt,g,{run(t){if(t.stamp<this.stamp)return t.StopPropagation;let e;return this.skip()?this.skip(!1):e=this.evaluate(t),e=e||t,e.then?e=e.then(n=>this.pulse=n):e!==t.StopPropagation&&(this.pulse=e),e},evaluate(t){const e=this.marshall(t.stamp),n=this.transform(e,t);return e.clear(),n},transform(){}});const Q={};function he(t){const e=pt(t);return e&&e.Definition||null}function pt(t){return t=t&&t.toLowerCase(),vt(Q,t)?Q[t]:null}export{ct as Dataflow,W as EventStream,B as MultiPulse,g as Operator,U as Parameters,y as Pulse,dt as Transform,q as UniqueList,I as asyncCallback,z as changeset,he as definition,Ot as derive,H as ingest,it as isChangeSet,Et as isTuple,nt as rederive,At as replace,St as stableCompare,pt as transform,Q as transforms,d as tupleid};export default null;
