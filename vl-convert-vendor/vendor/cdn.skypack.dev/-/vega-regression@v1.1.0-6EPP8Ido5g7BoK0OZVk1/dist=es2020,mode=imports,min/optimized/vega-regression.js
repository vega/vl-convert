import{regressionLoess as k,sampleCurve as z,regressionLinear as N,regressionLog as j,regressionExp as D,regressionPow as I,regressionQuad as P,regressionPoly as U}from"/-/vega-statistics@v1.8.0-ffGE4n8RjawoHviWdqFQ/dist=es2020,mode=imports,min/optimized/vega-statistics.js";import{Transform as w,ingest as x}from"/-/vega-dataflow@v5.7.4-DrCzG6Luqf74SfPN5Hxw/dist=es2020,mode=imports,min/optimized/vega-dataflow.js";import{inherits as L,accessorName as l,hasOwnProperty as F,error as G,extent as H}from"/-/vega-util@v1.17.0-uRskU0IBL2vWCP4Va8OC/dist=es2020,mode=imports,min/optimized/vega-util.js";function C(e,r){var t=[],p=function(f){return f(o)},u,i,s,o,n,a;if(r==null)t.push(e);else for(u={},i=0,s=e.length;i<s;++i)o=e[i],n=r.map(p),a=u[n],a||(u[n]=a=[],a.dims=n,t.push(a)),a.push(o);return t}function E(e){w.call(this,null,e)}E.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},L(E,w,{transform(e,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const p=r.materialize(r.SOURCE).source,u=C(p,e.groupby),i=(e.groupby||[]).map(l),s=i.length,o=e.as||[l(e.x),l(e.y)],n=[];u.forEach(a=>{k(a,e.x,e.y,e.bandwidth||.3).forEach(f=>{const m={};for(let d=0;d<s;++d)m[i[d]]=a.dims[d];m[o[0]]=f[0],m[o[1]]=f[1],n.push(x(m))})}),this.value&&(t.rem=this.value),this.value=t.add=t.source=n}return t}});const b={linear:N,log:j,exp:D,pow:I,quad:P,poly:U},Q=(e,r)=>e==="poly"?r:e==="quad"?2:1;function O(e){w.call(this,null,e)}O.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(b)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},L(O,w,{transform(e,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const p=r.materialize(r.SOURCE).source,u=C(p,e.groupby),i=(e.groupby||[]).map(l),s=e.method||"linear",o=e.order||3,n=Q(s,o),a=e.as||[l(e.x),l(e.y)],f=b[s],m=[];let d=e.extent;F(b,s)||G("Invalid regression method: "+s),d!=null&&(s==="log"&&d[0]<=0&&(r.dataflow.warn("Ignoring extent with values <= 0 for log regression."),d=null)),u.forEach(g=>{const R=g.length;if(R<=n){r.dataflow.warn("Skipping regression with more parameters than data points.");return}const h=f(g,e.x,e.y,o);if(e.params){m.push(x({keys:g.dims,coef:h.coef,rSquared:h.rSquared}));return}const q=d||H(g,e.x),S=c=>{const y={};for(let v=0;v<i.length;++v)y[i[v]]=g.dims[v];y[a[0]]=c[0],y[a[1]]=c[1],m.push(x(y))};s==="linear"?q.forEach(c=>S([c,h.predict(c)])):z(h.predict,q,25,200).forEach(S)}),this.value&&(t.rem=this.value),this.value=t.add=t.source=m}return t}});export{E as loess,O as regression};export default null;
