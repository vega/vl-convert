import{Transform as l,isTuple as K,ingest as w,stableCompare as N,tupleid as m}from"/-/vega-dataflow@v5.7.4-DrCzG6Luqf74SfPN5Hxw/dist=es2020,mode=imports,min/optimized/vega-dataflow.js";import{inherits as f,error as c,array as I,one as M,hasOwnProperty as C,truthy as j}from"/-/vega-util@v1.17.0-uRskU0IBL2vWCP4Va8OC/dist=es2020,mode=imports,min/optimized/vega-util.js";import{hierarchy as A,pack as $,partition as G,stratify as U,treemap as H,tree as V,cluster as F,treemapBinary as J,treemapDice as W,treemapSlice as X,treemapSliceDice as Q,treemapSquarify as Y,treemapResquarify as Z}from"/-/d3-hierarchy@v3.1.1-XUBgn8lKpyJLfwGxbbh8/dist=es2020,mode=imports,min/optimized/d3-hierarchy.js";function h(e,t,n){const s={};return e.each(a=>{const r=a.data;n(r)&&(s[t(r)]=a)}),e.lookup=s,e}function g(e){l.call(this,null,e)}g.Definition={type:"Nest",metadata:{treesource:!0,changes:!0},params:[{name:"keys",type:"field",array:!0},{name:"generate",type:"boolean"}]};const _=e=>e.values;f(g,l,{transform(e,t){t.source||c("Nest transform requires an upstream data source.");var n=e.generate,s=e.modified(),a=t.clone(),r=this.value;return(!r||s||t.changed())&&(r&&r.each(i=>{i.children&&K(i.data)&&a.rem.push(i.data)}),this.value=r=A({values:I(e.keys).reduce((i,o)=>(i.key(o),i),ee()).entries(a.source)},_),n&&r.each(i=>{i.children&&(i=w(i.data),a.add.push(i),a.source.push(i))}),h(r,m,m)),a.source.root=r,a}});function ee(){const e=[],t={entries:a=>s(n(a,0),0),key:a=>(e.push(a),t)};function n(a,r){if(r>=e.length)return a;const i=a.length,o=e[r++],d={},x={};let R=-1,p,y,P;for(;++R<i;)p=o(y=a[R])+"",(P=d[p])?P.push(y):d[p]=[y];for(p in d)x[p]=n(d[p],r);return x}function s(a,r){if(++r>e.length)return a;const i=[];for(const o in a)i.push({key:o,values:s(a[o],r)});return i}return t}function u(e){l.call(this,null,e)}const te=(e,t)=>e.parent===t.parent?1:2;f(u,l,{transform(e,t){(!t.source||!t.source.root)&&c(this.constructor.name+" transform requires a backing tree data source.");const n=this.layout(e.method),s=this.fields,a=t.source.root,r=e.as||s;e.field?a.sum(e.field):a.count(),e.sort&&a.sort(N(e.sort,i=>i.data)),ae(n,this.params,e),n.separation&&n.separation(e.separation!==!1?te:M);try{this.value=n(a)}catch(i){c(i)}return a.each(i=>re(i,s,r)),t.reflow(e.modified()).modifies(r).modifies("leaf")}});function ae(e,t,n){for(let s,a=0,r=t.length;a<r;++a)s=t[a],s in n&&e[s](n[s])}function re(e,t,n){const s=e.data,a=t.length-1;for(let r=0;r<a;++r)s[n[r]]=e[t[r]];s[n[a]]=e.children?e.children.length:0}const k=["x","y","r","depth","children"];function v(e){u.call(this,e)}v.Definition={type:"Pack",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"radius",type:"field",default:null},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:k.length,default:k}]},f(v,u,{layout:$,params:["radius","size","padding"],fields:k});const b=["x0","y0","x1","y1","depth","children"];function z(e){u.call(this,e)}z.Definition={type:"Partition",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"round",type:"boolean",default:!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:b.length,default:b}]},f(z,u,{layout:G,params:["size","round","padding"],fields:b});function D(e){l.call(this,null,e)}D.Definition={type:"Stratify",metadata:{treesource:!0},params:[{name:"key",type:"field",required:!0},{name:"parentKey",type:"field",required:!0}]},f(D,l,{transform(e,t){t.source||c("Stratify transform requires an upstream data source.");let n=this.value;const s=e.modified(),a=t.fork(t.ALL).materialize(t.SOURCE),r=!n||s||t.changed(t.ADD_REM)||t.modified(e.key.fields)||t.modified(e.parentKey.fields);return a.source=a.source.slice(),r&&(n=a.source.length?h(U().id(e.key).parentId(e.parentKey)(a.source),e.key,j):h(U()([{}]),e.key,e.key)),a.source.root=this.value=n,a}});const B={tidy:V,cluster:F},q=["x","y","depth","children"];function O(e){u.call(this,e)}O.Definition={type:"Tree",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"tidy",values:["tidy","cluster"]},{name:"size",type:"number",array:!0,length:2},{name:"nodeSize",type:"number",array:!0,length:2},{name:"separation",type:"boolean",default:!0},{name:"as",type:"string",array:!0,length:q.length,default:q}]},f(O,u,{layout(e){const t=e||"tidy";if(C(B,t))return B[t]();c("Unrecognized Tree layout method: "+t)},params:["size","nodeSize"],fields:q});function T(e){l.call(this,[],e)}T.Definition={type:"TreeLinks",metadata:{tree:!0,generates:!0,changes:!0},params:[]},f(T,l,{transform(e,t){const n=this.value,s=t.source&&t.source.root,a=t.fork(t.NO_SOURCE),r={};return s||c("TreeLinks transform requires a tree data source."),t.changed(t.ADD_REM)?(a.rem=n,t.visit(t.SOURCE,i=>r[m(i)]=1),s.each(i=>{const o=i.data,d=i.parent&&i.parent.data;d&&r[m(o)]&&r[m(d)]&&a.add.push(w({source:d,target:o}))}),this.value=a.add):t.changed(t.MOD)&&(t.visit(t.MOD,i=>r[m(i)]=1),n.forEach(i=>{(r[m(i.source)]||r[m(i.target)])&&a.mod.push(i)})),a}});const E={binary:J,dice:W,slice:X,slicedice:Q,squarify:Y,resquarify:Z},S=["x0","y0","x1","y1","depth","children"];function L(e){u.call(this,e)}L.Definition={type:"Treemap",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"squarify",values:["squarify","resquarify","binary","dice","slice","slicedice"]},{name:"padding",type:"number",default:0},{name:"paddingInner",type:"number",default:0},{name:"paddingOuter",type:"number",default:0},{name:"paddingTop",type:"number",default:0},{name:"paddingRight",type:"number",default:0},{name:"paddingBottom",type:"number",default:0},{name:"paddingLeft",type:"number",default:0},{name:"ratio",type:"number",default:1.618033988749895},{name:"round",type:"boolean",default:!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:S.length,default:S}]},f(L,u,{layout(){const e=H();return e.ratio=t=>{const n=e.tile();n.ratio&&e.tile(n.ratio(t))},e.method=t=>{C(E,t)?e.tile(E[t]):c("Unrecognized Treemap layout method: "+t)},e},params:["method","ratio","size","round","padding","paddingInner","paddingOuter","paddingTop","paddingRight","paddingBottom","paddingLeft"],fields:S});export{g as nest,v as pack,z as partition,D as stratify,O as tree,T as treelinks,L as treemap};export default null;
