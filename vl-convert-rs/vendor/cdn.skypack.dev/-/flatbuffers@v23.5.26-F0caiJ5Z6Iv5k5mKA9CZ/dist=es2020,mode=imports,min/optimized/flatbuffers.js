const f=2,n=4,h=4,y=4,a=new Int32Array(2),u=new Float32Array(a.buffer),I=new Float64Array(a.buffer),l=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;var _;(function(b){b[b.UTF8_BYTES=1]="UTF8_BYTES",b[b.UTF16_STRING=2]="UTF16_STRING"})(_||(_={}));class c{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new c(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return a[0]=this.readInt32(t),u[0]}readFloat64(t){return a[l?0:1]=this.readInt32(t),a[l?1:0]=this.readInt32(t+4),I[0]}writeInt8(t,i){this.bytes_[t]=i}writeUint8(t,i){this.bytes_[t]=i}writeInt16(t,i){this.bytes_[t]=i,this.bytes_[t+1]=i>>8}writeUint16(t,i){this.bytes_[t]=i,this.bytes_[t+1]=i>>8}writeInt32(t,i){this.bytes_[t]=i,this.bytes_[t+1]=i>>8,this.bytes_[t+2]=i>>16,this.bytes_[t+3]=i>>24}writeUint32(t,i){this.bytes_[t]=i,this.bytes_[t+1]=i>>8,this.bytes_[t+2]=i>>16,this.bytes_[t+3]=i>>24}writeInt64(t,i){this.writeInt32(t,Number(BigInt.asIntN(32,i))),this.writeInt32(t+4,Number(BigInt.asIntN(32,i>>BigInt(32))))}writeUint64(t,i){this.writeUint32(t,Number(BigInt.asUintN(32,i))),this.writeUint32(t+4,Number(BigInt.asUintN(32,i>>BigInt(32))))}writeFloat32(t,i){u[0]=i,this.writeInt32(t,a[0])}writeFloat64(t,i){I[0]=i,this.writeInt32(t,a[l?0:1]),this.writeInt32(t+4,a[l?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+n+h)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let i=0;i<h;i++)t+=String.fromCharCode(this.readInt8(this.position_+n+i));return t}__offset(t,i){const e=t-this.readInt32(t);return i<this.readInt16(e)?this.readInt16(e+i):0}__union(t,i){return t.bb_pos=i+this.readInt32(i),t.bb=this,t}__string(t,i){t+=this.readInt32(t);const e=this.readInt32(t);t+=n;const s=this.bytes_.subarray(t,t+e);return i===_.UTF8_BYTES?s:this.text_decoder_.decode(s)}__union_with_string(t,i){return typeof t=="string"?this.__string(i):this.__union(t,i)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+n}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=h)throw new Error("FlatBuffers: file identifier must be length "+h);for(let i=0;i<h;i++)if(t.charCodeAt(i)!=this.readInt8(this.position()+n+i))return!1;return!0}createScalarList(t,i){const e=[];for(let s=0;s<i;++s){const r=t(s);r!==null&&e.push(r)}return e}createObjList(t,i){const e=[];for(let s=0;s<i;++s){const r=t(s);r!==null&&e.push(r.unpack())}return e}}class p{constructor(t){this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder;let i;t?i=t:i=1024,this.bb=c.allocate(i),this.space=i}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,i){t>this.minalign&&(this.minalign=t);const e=~(this.bb.capacity()-this.space+i)+1&t-1;for(;this.space<e+t+i;){const s=this.bb.capacity();this.bb=p.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(e)}pad(t){for(let i=0;i<t;i++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,i,e){(this.force_defaults||i!=e)&&(this.addInt8(i),this.slot(t))}addFieldInt16(t,i,e){(this.force_defaults||i!=e)&&(this.addInt16(i),this.slot(t))}addFieldInt32(t,i,e){(this.force_defaults||i!=e)&&(this.addInt32(i),this.slot(t))}addFieldInt64(t,i,e){(this.force_defaults||i!==e)&&(this.addInt64(i),this.slot(t))}addFieldFloat32(t,i,e){(this.force_defaults||i!=e)&&(this.addFloat32(i),this.slot(t))}addFieldFloat64(t,i,e){(this.force_defaults||i!=e)&&(this.addFloat64(i),this.slot(t))}addFieldOffset(t,i,e){(this.force_defaults||i!=e)&&(this.addOffset(i),this.slot(t))}addFieldStruct(t,i,e){i!=e&&(this.nested(i),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const i=t.capacity();if(i&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const e=i<<1,s=c.allocate(e);return s.setPosition(e-i),s.bytes().set(t.bytes(),e-i),s}addOffset(t){this.prep(n,0),this.writeInt32(this.offset()-t+n)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let i=0;i<t;i++)this.vtable[i]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let i=this.vtable_in_use-1;for(;i>=0&&this.vtable[i]==0;i--);const e=i+1;for(;i>=0;i--)this.addInt16(this.vtable[i]!=0?t-this.vtable[i]:0);const s=2;this.addInt16(t-this.object_start);const r=(e+s)*f;this.addInt16(r);let o=0;const g=this.space;t:for(i=0;i<this.vtables.length;i++){const w=this.bb.capacity()-this.vtables[i];if(r==this.bb.readInt16(w)){for(let d=f;d<r;d+=f)if(this.bb.readInt16(g+d)!=this.bb.readInt16(w+d))continue t;o=this.vtables[i];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,i,e){const s=e?y:0;if(i){const r=i;if(this.prep(this.minalign,n+h+s),r.length!=h)throw new TypeError("FlatBuffers: file identifier must be length "+h);for(let o=h-1;o>=0;o--)this.writeInt8(r.charCodeAt(o))}this.prep(this.minalign,n+s),this.addOffset(t),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,i){this.finish(t,i,!0)}requiredField(t,i){const e=this.bb.capacity()-t,s=e-this.bb.readInt32(e),r=i<this.bb.readInt16(s)&&this.bb.readInt16(s+i)!=0;if(!r)throw new TypeError("FlatBuffers: field "+i+" must be set")}startVector(t,i,e){this.notNested(),this.vector_num_elems=i,this.prep(n,t*i),this.prep(e,t*i)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const i=this.createString(t);return this.string_maps.set(t,i),i}createString(t){if(t==null)return 0;let i;t instanceof Uint8Array?i=t:i=this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,i.length,1),this.bb.setPosition(this.space-=i.length);for(let e=0,s=this.space,r=this.bb.bytes();e<i.length;e++)r[s++]=i[e];return this.endVector()}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const i=[];for(let e=0;e<t.length;++e){const s=t[e];if(s!==null)i.push(this.createObjectOffset(s));else throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")}return i}createStructOffsetList(t,i){return i(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}export{p as Builder,c as ByteBuffer,_ as Encoding,h as FILE_IDENTIFIER_LENGTH,n as SIZEOF_INT,f as SIZEOF_SHORT,y as SIZE_PREFIX_LENGTH,u as float32,I as float64,a as int32,l as isLittleEndian};export default null;
