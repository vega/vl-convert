import{regressionLoess as z,sampleCurve as D,regressionLinear as I,regressionLog as C,regressionExp as N,regressionPow as P,regressionQuad as j,regressionPoly as F}from"/-/vega-statistics@v1.8.1-mXKADMfVQufwILOgkTiI/dist=es2020,mode=imports,min/optimized/vega-statistics.js";import{Transform as w,ingest as x}from"/-/vega-dataflow@v5.7.5-asKYS4gpPLMPf64pSozt/dist=es2020,mode=imports,min/optimized/vega-dataflow.js";import{inherits as q,accessorName as l,hasOwnProperty as U,error as M,extent as X}from"/-/vega-util@v1.17.1-uwuqwLZrXXBeO0DFYRgh/dist=es2020,mode=imports,min/optimized/vega-util.js";function k(e,r){var t=[],p=function(f){return f(o)},d,i,s,o,n,a;if(r==null)t.push(e);else for(d={},i=0,s=e.length;i<s;++i)o=e[i],n=r.map(p),a=d[n],a||(d[n]=a=[],a.dims=n,t.push(a)),a.push(o);return t}function O(e){w.call(this,null,e)}O.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},q(O,w,{transform(e,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const p=r.materialize(r.SOURCE).source,d=k(p,e.groupby),i=(e.groupby||[]).map(l),s=i.length,o=e.as||[l(e.x),l(e.y)],n=[];d.forEach(a=>{z(a,e.x,e.y,e.bandwidth||.3).forEach(f=>{const u={};for(let m=0;m<s;++m)u[i[m]]=a.dims[m];u[o[0]]=f[0],u[o[1]]=f[1],n.push(x(u))})}),this.value&&(t.rem=this.value),this.value=t.add=t.source=n}return t}});const b={linear:I,log:C,exp:N,pow:P,quad:j,poly:F},K=(e,r)=>e==="poly"?r:e==="quad"?2:1;function E(e){w.call(this,null,e)}E.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(b)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},q(E,w,{transform(e,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const p=r.materialize(r.SOURCE).source,d=k(p,e.groupby),i=(e.groupby||[]).map(l),s=e.method||"linear",o=e.order||3,n=K(s,o),a=e.as||[l(e.x),l(e.y)],f=b[s],u=[];let m=e.extent;U(b,s)||M("Invalid regression method: "+s),m!=null&&(s==="log"&&m[0]<=0&&(r.dataflow.warn("Ignoring extent with values <= 0 for log regression."),m=null)),d.forEach(g=>{const R=g.length;if(R<=n){r.dataflow.warn("Skipping regression with more parameters than data points.");return}const c=f(g,e.x,e.y,o);if(e.params){u.push(x({keys:g.dims,coef:c.coef,rSquared:c.rSquared}));return}const S=m||X(g,e.x),L=h=>{const y={};for(let v=0;v<i.length;++v)y[i[v]]=g.dims[v];y[a[0]]=h[0],y[a[1]]=h[1],u.push(x(y))};s==="linear"?S.forEach(h=>L([h,c.predict(h)])):D(c.predict,S,25,200).forEach(L)}),this.value&&(t.rem=this.value),this.value=t.add=t.source=u}return t}});export{O as loess,E as regression};export default null;
