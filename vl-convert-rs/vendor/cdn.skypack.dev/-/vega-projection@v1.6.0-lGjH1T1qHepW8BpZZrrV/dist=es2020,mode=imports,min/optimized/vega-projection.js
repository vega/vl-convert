import{geoPath as n,geoAlbers as u,geoAlbersUsa as g,geoAzimuthalEqualArea as m,geoAzimuthalEquidistant as p,geoConicConformal as d,geoConicEqualArea as h,geoConicEquidistant as f,geoEqualEarth as E,geoEquirectangular as j,geoGnomonic as q,geoIdentity as A,geoMercator as w,geoNaturalEarth1 as z,geoOrthographic as b,geoStereographic as v,geoTransverseMercator as C}from"/-/d3-geo@v3.1.0-6gCuCN3p6hXOeZDWcbjw/dist=es2020,mode=imports,min/optimized/d3-geo.js";import{geoMollweide as P}from"/-/d3-geo-projection@v4.0.0-5Hhxj2zKHEqWYAQIFo3r/dist=es2020,mode=imports,min/optimized/d3-geo-projection.js";import{registerScale as x}from"/-/vega-scale@v7.3.0-RE8rHwByiw8oUoAe4pNs/dist=es2020,mode=imports,min/optimized/vega-scale.js";const y=n(),c=["clipAngle","clipExtent","scale","translate","center","rotate","parallels","precision","reflectX","reflectY","coefficient","distance","fraction","lobes","parallel","radius","ratio","spacing","tilt"];function H(e,r){return function l(){const o=r();return o.type=e,o.path=n().projection(o),o.copy=o.copy||function(){const i=l();return c.forEach(a=>{o[a]&&i[a](o[a]())}),i.path.pointRadius(o.path.pointRadius()),i},x(o)}}function s(e,r){if(!e||typeof e!="string")throw new Error("Projection type must be a name string.");return e=e.toLowerCase(),arguments.length>1?(t[e]=H(e,r),this):t[e]||null}function M(e){return e&&e.path||y}const t={albers:u,albersusa:g,azimuthalequalarea:m,azimuthalequidistant:p,conicconformal:d,conicequalarea:h,conicequidistant:f,equalEarth:E,equirectangular:j,gnomonic:q,identity:A,mercator:w,mollweide:P,naturalEarth1:z,orthographic:b,stereographic:v,transversemercator:C};for(const e in t)s(e,t[e]);export{M as getProjectionPath,s as projection,c as projectionProperties};export default null;
