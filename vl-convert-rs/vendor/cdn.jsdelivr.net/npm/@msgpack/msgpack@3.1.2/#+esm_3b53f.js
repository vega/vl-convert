/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@msgpack/msgpack@3.1.2/dist.esm/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const t=new TextEncoder;function e(e,i,s){e.length>50?function(e,i,s){t.encodeInto(e,i.subarray(s))}(e,i,s):function(t,e,i){const s=t.length;let n=i,r=0;for(;r<s;){let i=t.charCodeAt(r++);if(4294967168&i){if(4294965248&i){if(i>=55296&&i<=56319&&r<s){const e=t.charCodeAt(r);56320==(64512&e)&&(++r,i=((1023&i)<<10)+(1023&e)+65536)}4294901760&i?(e[n++]=i>>18&7|240,e[n++]=i>>12&63|128,e[n++]=i>>6&63|128):(e[n++]=i>>12&15|224,e[n++]=i>>6&63|128)}else e[n++]=i>>6&31|192;e[n++]=63&i|128}else e[n++]=i}}(e,i,s)}function i(t,e,i){let s=e;const n=s+i,r=[];let o="";for(;s<n;){const e=t[s++];if(128&e)if(192==(224&e)){const i=63&t[s++];r.push((31&e)<<6|i)}else if(224==(240&e)){const i=63&t[s++],n=63&t[s++];r.push((31&e)<<12|i<<6|n)}else if(240==(248&e)){let i=(7&e)<<18|(63&t[s++])<<12|(63&t[s++])<<6|63&t[s++];i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i)}else r.push(e);else r.push(e);r.length>=4096&&(o+=String.fromCharCode(...r),r.length=0)}return r.length>0&&(o+=String.fromCharCode(...r)),o}const s=new TextDecoder;function n(t,e,n){return n>200?function(t,e,i){const n=t.subarray(e,e+i);return s.decode(n)}(t,e,n):i(t,e,n)}class r{constructor(t,e){this.type=t,this.data=e}}class o extends Error{constructor(t){super(t);const e=Object.create(o.prototype);Object.setPrototypeOf(this,e),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:o.name})}}const h=4294967295;function a(t,e,i){const s=Math.floor(i/4294967296),n=i;t.setUint32(e,s),t.setUint32(e+4,n)}function c(t,e){return 4294967296*t.getInt32(e)+t.getUint32(e+4)}const d=-1;function f({sec:t,nsec:e}){if(t>=0&&e>=0&&t<=17179869183){if(0===e&&t<=4294967295){const e=new Uint8Array(4);return new DataView(e.buffer).setUint32(0,t),e}{const i=t/4294967296,s=4294967295&t,n=new Uint8Array(8),r=new DataView(n.buffer);return r.setUint32(0,e<<2|3&i),r.setUint32(4,s),n}}{const i=new Uint8Array(12),s=new DataView(i.buffer);return s.setUint32(0,e),a(s,4,t),i}}function l(t){const e=t.getTime(),i=Math.floor(e/1e3),s=1e6*(e-1e3*i),n=Math.floor(s/1e9);return{sec:i+n,nsec:s-1e9*n}}function u(t){if(t instanceof Date){return f(l(t))}return null}function w(t){const e=new DataView(t.buffer,t.byteOffset,t.byteLength);switch(t.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const t=e.getUint32(0);return{sec:4294967296*(3&t)+e.getUint32(4),nsec:t>>>2}}case 12:return{sec:c(e,4),nsec:e.getUint32(0)};default:throw new o(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${t.length}`)}}function y(t){const e=w(t);return new Date(1e3*e.sec+e.nsec/1e6)}const p={type:-1,encode:u,decode:y};class g{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(p)}register({type:t,encode:e,decode:i}){if(t>=0)this.encoders[t]=e,this.decoders[t]=i;else{const s=-1-t;this.builtInEncoders[s]=e,this.builtInDecoders[s]=i}}tryToEncode(t,e){for(let i=0;i<this.builtInEncoders.length;i++){const s=this.builtInEncoders[i];if(null!=s){const n=s(t,e);if(null!=n){return new r(-1-i,n)}}}for(let i=0;i<this.encoders.length;i++){const s=this.encoders[i];if(null!=s){const n=s(t,e);if(null!=n){return new r(i,n)}}}return t instanceof r?t:null}decode(t,e,i){const s=e<0?this.builtInDecoders[-1-e]:this.decoders[e];return s?s(t,e,i):new r(e,t)}}function U(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):function(t){return t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer}(t)?new Uint8Array(t):Uint8Array.from(t)}g.defaultCodec=new g;class x{constructor(t){this.entered=!1,this.extensionCodec=t?.extensionCodec??g.defaultCodec,this.context=t?.context,this.useBigInt64=t?.useBigInt64??!1,this.maxDepth=t?.maxDepth??100,this.initialBufferSize=t?.initialBufferSize??2048,this.sortKeys=t?.sortKeys??!1,this.forceFloat32=t?.forceFloat32??!1,this.ignoreUndefined=t?.ignoreUndefined??!1,this.forceIntegerToFloat=t?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new x({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(t){if(this.entered){return this.clone().encodeSharedRef(t)}try{return this.entered=!0,this.reinitializeState(),this.doEncode(t,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(t){if(this.entered){return this.clone().encode(t)}try{return this.entered=!0,this.reinitializeState(),this.doEncode(t,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(t,e){if(e>this.maxDepth)throw new Error(`Too deep objects in depth ${e}`);null==t?this.encodeNil():"boolean"==typeof t?this.encodeBoolean(t):"number"==typeof t?this.forceIntegerToFloat?this.encodeNumberAsFloat(t):this.encodeNumber(t):"string"==typeof t?this.encodeString(t):this.useBigInt64&&"bigint"==typeof t?this.encodeBigInt64(t):this.encodeObject(t,e)}ensureBufferSizeToWrite(t){const e=this.pos+t;this.view.byteLength<e&&this.resizeBuffer(2*e)}resizeBuffer(t){const e=new ArrayBuffer(t),i=new Uint8Array(e),s=new DataView(e);i.set(this.bytes),this.view=s,this.bytes=i}encodeNil(){this.writeU8(192)}encodeBoolean(t){!1===t?this.writeU8(194):this.writeU8(195)}encodeNumber(t){!this.forceIntegerToFloat&&Number.isSafeInteger(t)?t>=0?t<128?this.writeU8(t):t<256?(this.writeU8(204),this.writeU8(t)):t<65536?(this.writeU8(205),this.writeU16(t)):t<4294967296?(this.writeU8(206),this.writeU32(t)):this.useBigInt64?this.encodeNumberAsFloat(t):(this.writeU8(207),this.writeU64(t)):t>=-32?this.writeU8(224|t+32):t>=-128?(this.writeU8(208),this.writeI8(t)):t>=-32768?(this.writeU8(209),this.writeI16(t)):t>=-2147483648?(this.writeU8(210),this.writeI32(t)):this.useBigInt64?this.encodeNumberAsFloat(t):(this.writeU8(211),this.writeI64(t)):this.encodeNumberAsFloat(t)}encodeNumberAsFloat(t){this.forceFloat32?(this.writeU8(202),this.writeF32(t)):(this.writeU8(203),this.writeF64(t))}encodeBigInt64(t){t>=BigInt(0)?(this.writeU8(207),this.writeBigUint64(t)):(this.writeU8(211),this.writeBigInt64(t))}writeStringHeader(t){if(t<32)this.writeU8(160+t);else if(t<256)this.writeU8(217),this.writeU8(t);else if(t<65536)this.writeU8(218),this.writeU16(t);else{if(!(t<4294967296))throw new Error(`Too long string: ${t} bytes in UTF-8`);this.writeU8(219),this.writeU32(t)}}encodeString(t){const i=function(t){const e=t.length;let i=0,s=0;for(;s<e;){let n=t.charCodeAt(s++);if(4294967168&n)if(4294965248&n){if(n>=55296&&n<=56319&&s<e){const e=t.charCodeAt(s);56320==(64512&e)&&(++s,n=((1023&n)<<10)+(1023&e)+65536)}i+=4294901760&n?4:3}else i+=2;else i++}return i}(t);this.ensureBufferSizeToWrite(5+i),this.writeStringHeader(i),e(t,this.bytes,this.pos),this.pos+=i}encodeObject(t,e){const i=this.extensionCodec.tryToEncode(t,this.context);if(null!=i)this.encodeExtension(i);else if(Array.isArray(t))this.encodeArray(t,e);else if(ArrayBuffer.isView(t))this.encodeBinary(t);else{if("object"!=typeof t)throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(t)}`);this.encodeMap(t,e)}}encodeBinary(t){const e=t.byteLength;if(e<256)this.writeU8(196),this.writeU8(e);else if(e<65536)this.writeU8(197),this.writeU16(e);else{if(!(e<4294967296))throw new Error(`Too large binary: ${e}`);this.writeU8(198),this.writeU32(e)}const i=U(t);this.writeU8a(i)}encodeArray(t,e){const i=t.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error(`Too large array: ${i}`);this.writeU8(221),this.writeU32(i)}for(const i of t)this.doEncode(i,e+1)}countWithoutUndefined(t,e){let i=0;for(const s of e)void 0!==t[s]&&i++;return i}encodeMap(t,e){const i=Object.keys(t);this.sortKeys&&i.sort();const s=this.ignoreUndefined?this.countWithoutUndefined(t,i):i.length;if(s<16)this.writeU8(128+s);else if(s<65536)this.writeU8(222),this.writeU16(s);else{if(!(s<4294967296))throw new Error(`Too large map object: ${s}`);this.writeU8(223),this.writeU32(s)}for(const s of i){const i=t[s];this.ignoreUndefined&&void 0===i||(this.encodeString(s),this.doEncode(i,e+1))}}encodeExtension(t){if("function"==typeof t.data){const e=t.data(this.pos+6),i=e.length;if(i>=4294967296)throw new Error(`Too large extension object: ${i}`);return this.writeU8(201),this.writeU32(i),this.writeI8(t.type),void this.writeU8a(e)}const e=t.data.length;if(1===e)this.writeU8(212);else if(2===e)this.writeU8(213);else if(4===e)this.writeU8(214);else if(8===e)this.writeU8(215);else if(16===e)this.writeU8(216);else if(e<256)this.writeU8(199),this.writeU8(e);else if(e<65536)this.writeU8(200),this.writeU16(e);else{if(!(e<4294967296))throw new Error(`Too large extension object: ${e}`);this.writeU8(201),this.writeU32(e)}this.writeI8(t.type),this.writeU8a(t.data)}writeU8(t){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,t),this.pos++}writeU8a(t){const e=t.length;this.ensureBufferSizeToWrite(e),this.bytes.set(t,this.pos),this.pos+=e}writeI8(t){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,t),this.pos++}writeU16(t){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,t),this.pos+=2}writeI16(t){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,t),this.pos+=2}writeU32(t){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,t),this.pos+=4}writeI32(t){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,t),this.pos+=4}writeF32(t){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,t),this.pos+=4}writeF64(t){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,t),this.pos+=8}writeU64(t){this.ensureBufferSizeToWrite(8),function(t,e,i){const s=i/4294967296,n=i;t.setUint32(e,s),t.setUint32(e+4,n)}(this.view,this.pos,t),this.pos+=8}writeI64(t){this.ensureBufferSizeToWrite(8),a(this.view,this.pos,t),this.pos+=8}writeBigUint64(t){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,t),this.pos+=8}writeBigInt64(t){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,t),this.pos+=8}}function m(t,e){return new x(e).encodeSharedRef(t)}function B(t){return`${t<0?"-":""}0x${Math.abs(t).toString(16).padStart(2,"0")}`}const b="array",S="map_key",I="map_value",A=t=>{if("string"==typeof t||"number"==typeof t)return t;throw new o("The type of key must be string or number but "+typeof t)};class E{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(t){const e=this.getUninitializedStateFromPool();e.type=b,e.position=0,e.size=t,e.array=new Array(t)}pushMapState(t){const e=this.getUninitializedStateFromPool();e.type=S,e.readCount=0,e.size=t,e.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const t={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(t)}return this.stack[this.stackHeadPosition]}release(t){if(this.stack[this.stackHeadPosition]!==t)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(t.type===b){const e=t;e.size=0,e.array=void 0,e.position=0,e.type=void 0}if(t.type===S||t.type===I){const e=t;e.size=0,e.map=void 0,e.readCount=0,e.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}const v=new DataView(new ArrayBuffer(0)),k=new Uint8Array(v.buffer);try{v.getInt8(0)}catch(t){if(!(t instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}const L=new RangeError("Insufficient data"),z=new class{constructor(t=16,e=16){this.hit=0,this.miss=0,this.maxKeyLength=t,this.maxLengthPerKey=e,this.caches=[];for(let t=0;t<this.maxKeyLength;t++)this.caches.push([])}canBeCached(t){return t>0&&t<=this.maxKeyLength}find(t,e,i){const s=this.caches[i-1];t:for(const n of s){const s=n.bytes;for(let n=0;n<i;n++)if(s[n]!==t[e+n])continue t;return n.str}return null}store(t,e){const i=this.caches[t.length-1],s={bytes:t,str:e};i.length>=this.maxLengthPerKey?i[Math.random()*i.length|0]=s:i.push(s)}decode(t,e,s){const n=this.find(t,e,s);if(null!=n)return this.hit++,n;this.miss++;const r=i(t,e,s),o=Uint8Array.prototype.slice.call(t,e,e+s);return this.store(o,r),r}};class T{constructor(t){this.totalPos=0,this.pos=0,this.view=v,this.bytes=k,this.headByte=-1,this.stack=new E,this.entered=!1,this.extensionCodec=t?.extensionCodec??g.defaultCodec,this.context=t?.context,this.useBigInt64=t?.useBigInt64??!1,this.rawStrings=t?.rawStrings??!1,this.maxStrLength=t?.maxStrLength??h,this.maxBinLength=t?.maxBinLength??h,this.maxArrayLength=t?.maxArrayLength??h,this.maxMapLength=t?.maxMapLength??h,this.maxExtLength=t?.maxExtLength??h,this.keyDecoder=void 0!==t?.keyDecoder?t.keyDecoder:z,this.mapKeyConverter=t?.mapKeyConverter??A}clone(){return new T({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=-1,this.stack.reset()}setBuffer(t){const e=U(t);this.bytes=e,this.view=new DataView(e.buffer,e.byteOffset,e.byteLength),this.pos=0}appendBuffer(t){if(-1!==this.headByte||this.hasRemaining(1)){const e=this.bytes.subarray(this.pos),i=U(t),s=new Uint8Array(e.length+i.length);s.set(e),s.set(i,e.length),this.setBuffer(s)}else this.setBuffer(t)}hasRemaining(t){return this.view.byteLength-this.pos>=t}createExtraByteError(t){const{view:e,pos:i}=this;return new RangeError(`Extra ${e.byteLength-i} of ${e.byteLength} byte(s) found at buffer[${t}]`)}decode(t){if(this.entered){return this.clone().decode(t)}try{this.entered=!0,this.reinitializeState(),this.setBuffer(t);const e=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return e}finally{this.entered=!1}}*decodeMulti(t){if(this.entered){const e=this.clone();yield*e.decodeMulti(t)}else try{for(this.entered=!0,this.reinitializeState(),this.setBuffer(t);this.hasRemaining(1);)yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(t){if(this.entered){return this.clone().decodeAsync(t)}try{this.entered=!0;let e,i=!1;for await(const s of t){if(i)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(s);try{e=this.doDecodeSync(),i=!0}catch(t){if(!(t instanceof RangeError))throw t}this.totalPos+=this.pos}if(i){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return e}const{headByte:s,pos:n,totalPos:r}=this;throw new RangeError(`Insufficient data in parsing ${B(s)} at ${r} (${n} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(t){return this.decodeMultiAsync(t,!0)}decodeStream(t){return this.decodeMultiAsync(t,!1)}async*decodeMultiAsync(t,e){if(this.entered){const i=this.clone();yield*i.decodeMultiAsync(t,e)}else try{this.entered=!0;let i=e,s=-1;for await(const n of t){if(e&&0===s)throw this.createExtraByteError(this.totalPos);this.appendBuffer(n),i&&(s=this.readArraySize(),i=!1,this.complete());try{for(;yield this.doDecodeSync(),0!=--s;);}catch(t){if(!(t instanceof RangeError))throw t}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){t:for(;;){const t=this.readHeadByte();let e;if(t>=224)e=t-256;else if(t<192)if(t<128)e=t;else if(t<144){const i=t-128;if(0!==i){this.pushMapState(i),this.complete();continue t}e={}}else if(t<160){const i=t-144;if(0!==i){this.pushArrayState(i),this.complete();continue t}e=[]}else{const i=t-160;e=this.decodeString(i,0)}else if(192===t)e=null;else if(194===t)e=!1;else if(195===t)e=!0;else if(202===t)e=this.readF32();else if(203===t)e=this.readF64();else if(204===t)e=this.readU8();else if(205===t)e=this.readU16();else if(206===t)e=this.readU32();else if(207===t)e=this.useBigInt64?this.readU64AsBigInt():this.readU64();else if(208===t)e=this.readI8();else if(209===t)e=this.readI16();else if(210===t)e=this.readI32();else if(211===t)e=this.useBigInt64?this.readI64AsBigInt():this.readI64();else if(217===t){const t=this.lookU8();e=this.decodeString(t,1)}else if(218===t){const t=this.lookU16();e=this.decodeString(t,2)}else if(219===t){const t=this.lookU32();e=this.decodeString(t,4)}else if(220===t){const t=this.readU16();if(0!==t){this.pushArrayState(t),this.complete();continue t}e=[]}else if(221===t){const t=this.readU32();if(0!==t){this.pushArrayState(t),this.complete();continue t}e=[]}else if(222===t){const t=this.readU16();if(0!==t){this.pushMapState(t),this.complete();continue t}e={}}else if(223===t){const t=this.readU32();if(0!==t){this.pushMapState(t),this.complete();continue t}e={}}else if(196===t){const t=this.lookU8();e=this.decodeBinary(t,1)}else if(197===t){const t=this.lookU16();e=this.decodeBinary(t,2)}else if(198===t){const t=this.lookU32();e=this.decodeBinary(t,4)}else if(212===t)e=this.decodeExtension(1,0);else if(213===t)e=this.decodeExtension(2,0);else if(214===t)e=this.decodeExtension(4,0);else if(215===t)e=this.decodeExtension(8,0);else if(216===t)e=this.decodeExtension(16,0);else if(199===t){const t=this.lookU8();e=this.decodeExtension(t,1)}else if(200===t){const t=this.lookU16();e=this.decodeExtension(t,2)}else{if(201!==t)throw new o(`Unrecognized type byte: ${B(t)}`);{const t=this.lookU32();e=this.decodeExtension(t,4)}}this.complete();const i=this.stack;for(;i.length>0;){const t=i.top();if(t.type===b){if(t.array[t.position]=e,t.position++,t.position!==t.size)continue t;e=t.array,i.release(t)}else{if(t.type===S){if("__proto__"===e)throw new o("The key __proto__ is not allowed");t.key=this.mapKeyConverter(e),t.type=I;continue t}if(t.map[t.key]=e,t.readCount++,t.readCount!==t.size){t.key=null,t.type=S;continue t}e=t.map,i.release(t)}}return e}}readHeadByte(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=-1}readArraySize(){const t=this.readHeadByte();switch(t){case 220:return this.readU16();case 221:return this.readU32();default:if(t<160)return t-144;throw new o(`Unrecognized array type byte: ${B(t)}`)}}pushMapState(t){if(t>this.maxMapLength)throw new o(`Max length exceeded: map length (${t}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(t)}pushArrayState(t){if(t>this.maxArrayLength)throw new o(`Max length exceeded: array length (${t}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(t)}decodeString(t,e){return!this.rawStrings||this.stateIsMapKey()?this.decodeUtf8String(t,e):this.decodeBinary(t,e)}decodeUtf8String(t,e){if(t>this.maxStrLength)throw new o(`Max length exceeded: UTF-8 byte length (${t}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+e+t)throw L;const i=this.pos+e;let s;return s=this.stateIsMapKey()&&this.keyDecoder?.canBeCached(t)?this.keyDecoder.decode(this.bytes,i,t):n(this.bytes,i,t),this.pos+=e+t,s}stateIsMapKey(){if(this.stack.length>0){return this.stack.top().type===S}return!1}decodeBinary(t,e){if(t>this.maxBinLength)throw new o(`Max length exceeded: bin length (${t}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(t+e))throw L;const i=this.pos+e,s=this.bytes.subarray(i,i+t);return this.pos+=e+t,s}decodeExtension(t,e){if(t>this.maxExtLength)throw new o(`Max length exceeded: ext length (${t}) > maxExtLength (${this.maxExtLength})`);const i=this.view.getInt8(this.pos+e),s=this.decodeBinary(t,e+1);return this.extensionCodec.decode(s,i,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const t=this.view.getUint8(this.pos);return this.pos++,t}readI8(){const t=this.view.getInt8(this.pos);return this.pos++,t}readU16(){const t=this.view.getUint16(this.pos);return this.pos+=2,t}readI16(){const t=this.view.getInt16(this.pos);return this.pos+=2,t}readU32(){const t=this.view.getUint32(this.pos);return this.pos+=4,t}readI32(){const t=this.view.getInt32(this.pos);return this.pos+=4,t}readU64(){const t=(e=this.view,i=this.pos,4294967296*e.getUint32(i)+e.getUint32(i+4));var e,i;return this.pos+=8,t}readI64(){const t=c(this.view,this.pos);return this.pos+=8,t}readU64AsBigInt(){const t=this.view.getBigUint64(this.pos);return this.pos+=8,t}readI64AsBigInt(){const t=this.view.getBigInt64(this.pos);return this.pos+=8,t}readF32(){const t=this.view.getFloat32(this.pos);return this.pos+=4,t}readF64(){const t=this.view.getFloat64(this.pos);return this.pos+=8,t}}function M(t,e){return new T(e).decode(t)}function F(t,e){return new T(e).decodeMulti(t)}function D(t){return null!=t[Symbol.asyncIterator]?t:async function*(t){const e=t.getReader();try{for(;;){const{done:t,value:i}=await e.read();if(t)return;yield i}}finally{e.releaseLock()}}(t)}async function C(t,e){const i=D(t);return new T(e).decodeAsync(i)}function $(t,e){const i=D(t);return new T(e).decodeArrayStream(i)}function P(t,e){const i=D(t);return new T(e).decodeStream(i)}export{o as DecodeError,T as Decoder,d as EXT_TIMESTAMP,x as Encoder,r as ExtData,g as ExtensionCodec,M as decode,$ as decodeArrayStream,C as decodeAsync,F as decodeMulti,P as decodeMultiStream,y as decodeTimestampExtension,w as decodeTimestampToTimeSpec,m as encode,l as encodeDateToTimeSpec,f as encodeTimeSpecToTimestamp,u as encodeTimestampExtension};export default null;
//# sourceMappingURL=/sm/e2beffac7807d754cc0b5008ec864a7be4900e933f994c0ef0a6fa6af3b612dd.map