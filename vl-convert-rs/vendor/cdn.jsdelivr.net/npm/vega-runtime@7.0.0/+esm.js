/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/vega-runtime@7.0.0/build/vega-runtime.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{toSet as e,stringValue as t,error as n,isArray as r,isObject as s,hasOwnProperty as o,accessor as a,key as i,field as c,array as u,compare as p,truthy as f}from"/npm/vega-util@2.0.0/+esm";import{tupleid as d}from"/npm/vega-dataflow@6.0.0/+esm";const l=e(["rule"]),h=e(["group","image","rect"]);function m(e){return(e+"").toLowerCase()}function $(e,t,n){n.endsWith(";")||(n="return("+n+");");const r=Function(...t.concat(n));return e&&e.functions?r.bind(e.functions):r}var g={operator:(e,t)=>$(e,["_"],t.code),parameter:(e,t)=>$(e,["datum","_"],t.code),event:(e,t)=>$(e,["event"],t.code),handler:(e,t)=>$(e,["_","event"],`var datum=event.item&&event.item.datum;return ${t.code};`),encode:(e,n)=>{const{marktype:r,channels:s}=n;let o="var o=item,datum=o.datum,m=0,$;";for(const e in s){const n="o["+t(e)+"]";o+=`$=${s[e].code};if(${n}!==$)${n}=$,m=1;`}return o+=function(e,t){let n="";return l[t]||(e.x2&&(e.x?(h[t]&&(n+="if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"),n+="o.width=o.x2-o.x;"):n+="o.x=o.x2-(o.width||0);"),e.xc&&(n+="o.x=o.xc-(o.width||0)/2;"),e.y2&&(e.y?(h[t]&&(n+="if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"),n+="o.height=o.y2-o.y;"):n+="o.y=o.y2-(o.height||0);"),e.yc&&(n+="o.y=o.yc-(o.height||0)/2;")),n}(s,r),o+="return m;",$(e,["item","_"],o)},codegen:{get(e){const n=`[${e.map(t).join("][")}]`,r=Function("_",`return _${n};`);return r.path=n,r},comparator(e,t){let n;const r=Function("a","b","var u, v; return "+e.map(((e,r)=>{const s=t[r];let o,a;return e.path?(o=`a${e.path}`,a=`b${e.path}`):((n=n||{})["f"+r]=e,o=`this.f${r}(a)`,a=`this.f${r}(b)`),function(e,t,n,r){return`((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}\n  : (u > v || v == null) && u != null ? ${r}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}\n  : v !== v && u === u ? ${r} : `}(o,a,-s,s)})).join("")+"0;");return n?r.bind(n):r}}};function v(e,t,n){if(!e||!s(e))return e;for(let r,s=0,a=x.length;s<a;++s)if(r=x[s],o(e,r.key))return r.parse(e,t,n);return e}var x=[{key:"$ref",parse:function(e,t){return t.get(e.$ref)||n("Operator not defined: "+e.$ref)}},{key:"$key",parse:function(e,t){const n="k:"+e.$key+"_"+!!e.$flat;return t.fn[n]||(t.fn[n]=i(e.$key,e.$flat,t.expr.codegen))}},{key:"$expr",parse:function(e,t,n){e.$params&&t.parseParameters(e.$params,n);const r="e:"+e.$expr.code;return t.fn[r]||(t.fn[r]=a(t.parameterExpression(e.$expr),e.$fields))}},{key:"$field",parse:function(e,t){if(!e.$field)return null;const n="f:"+e.$field+"_"+e.$name;return t.fn[n]||(t.fn[n]=c(e.$field,e.$name,t.expr.codegen))}},{key:"$encode",parse:function(e,t){const n=e.$encode,r={};for(const e in n){const s=n[e];r[e]=a(t.encodeExpression(s.$expr),s.$fields),r[e].output=s.$output}return r}},{key:"$compare",parse:function(e,t){const n="c:"+e.$compare+"_"+e.$order,r=u(e.$compare).map((e=>e&&e.$tupleid?d:e));return t.fn[n]||(t.fn[n]=p(r,e.$order,t.expr.codegen))}},{key:"$context",parse:function(e,t){return t}},{key:"$subflow",parse:function(e,t){const n=e.$subflow;return function(e,r,s){const o=t.fork().parse(n),a=o.get(n.operators[0].id),i=o.signals.parent;return i&&i.set(s),a.detachSubflow=()=>t.detach(o),a}}},{key:"$tupleid",parse:function(){return d}}];const y={skip:!0};function b(e,t,n,r){return new k(e,t,n,r)}function k(e,t,n,r){this.dataflow=e,this.transforms=t,this.events=e.events.bind(e),this.expr=r||g,this.signals={},this.scales={},this.nodes={},this.data={},this.fn={},n&&(this.functions=Object.create(n),this.functions.context=this)}function w(e){this.dataflow=e.dataflow,this.transforms=e.transforms,this.events=e.events,this.expr=e.expr,this.signals=Object.create(e.signals),this.scales=Object.create(e.scales),this.nodes=Object.create(e.nodes),this.data=Object.create(e.data),this.fn=Object.create(e.fn),e.functions&&(this.functions=Object.create(e.functions),this.functions.context=this)}k.prototype=w.prototype={fork(){const e=new w(this);return(this.subcontext||(this.subcontext=[])).push(e),e},detach(e){this.subcontext=this.subcontext.filter((t=>t!==e));const t=Object.keys(e.nodes);for(const n of t)e.nodes[n]._targets=null;for(const n of t)e.nodes[n].detach();e.nodes=null},get(e){return this.nodes[e]},set(e,t){return this.nodes[e]=t},add(e,t){const n=this,r=n.dataflow,s=e.value;if(n.set(e.id,t),"collect"===m(e.type)&&s&&(s.$ingest?r.ingest(t,s.$ingest,s.$format):s.$request?r.preload(t,s.$request,s.$format):r.pulse(t,r.changeset().insert(s))),e.root&&(n.root=t),e.parent){let s=n.get(e.parent.$ref);s?(r.connect(s,[t]),t.targets().add(s)):(n.unresolved=n.unresolved||[]).push((()=>{s=n.get(e.parent.$ref),r.connect(s,[t]),t.targets().add(s)}))}if(e.signal&&(n.signals[e.signal]=t),e.scale&&(n.scales[e.scale]=t),e.data)for(const r in e.data){const s=n.data[r]||(n.data[r]={});e.data[r].forEach((e=>s[e]=t))}},resolve(){return(this.unresolved||[]).forEach((e=>e())),delete this.unresolved,this},operator(e,t){this.add(e,this.dataflow.add(e.value,t))},transform(e,t){this.add(e,this.dataflow.add(this.transforms[m(t)]))},stream(e,t){this.set(e.id,t)},update(e,t,n,r,s){this.dataflow.on(t,n,r,s,e.options)},operatorExpression(e){return this.expr.operator(this,e)},parameterExpression(e){return this.expr.parameter(this,e)},eventExpression(e){return this.expr.event(this,e)},handlerExpression(e){return this.expr.handler(this,e)},encodeExpression(e){return this.expr.encode(this,e)},parse:function(e){const t=this,n=e.operators||[];return e.background&&(t.background=e.background),e.eventConfig&&(t.eventConfig=e.eventConfig),e.locale&&(t.locale=e.locale),n.forEach((e=>t.parseOperator(e))),n.forEach((e=>t.parseOperatorParameters(e))),(e.streams||[]).forEach((e=>t.parseStream(e))),(e.updates||[]).forEach((e=>t.parseUpdate(e))),t.resolve()},parseOperator:function(e){const t=this;"operator"!==m(e.type)&&e.type?t.transform(e,e.type):t.operator(e,e.update?t.operatorExpression(e.update):null)},parseOperatorParameters:function(e){const t=this;if(e.params){const r=t.get(e.id);r||n("Invalid operator id: "+e.id),t.dataflow.connect(r,r.parameters(t.parseParameters(e.params),e.react,e.initonly))}},parseParameters:function(e,t){t=t||{};const n=this;for(const s in e){const o=e[s];t[s]=r(o)?o.map((e=>v(e,n,t))):v(o,n,t)}return t},parseStream:function(e){var t,r=this,s=null!=e.filter?r.eventExpression(e.filter):void 0,o=null!=e.stream?r.get(e.stream):void 0;e.source?o=r.events(e.source,e.type,s):e.merge&&(o=(t=e.merge.map((e=>r.get(e))))[0].merge.apply(t[0],t.slice(1))),e.between&&(t=e.between.map((e=>r.get(e))),o=o.between(t[0],t[1])),e.filter&&(o=o.filter(s)),null!=e.throttle&&(o=o.throttle(+e.throttle)),null!=e.debounce&&(o=o.debounce(+e.debounce)),null==o&&n("Invalid stream definition: "+JSON.stringify(e)),e.consume&&o.consume(!0),r.stream(e,o)},parseUpdate:function(e){var t,r=this,o=s(o=e.source)?o.$ref:o,a=r.get(o),i=e.update,c=void 0;a||n("Source not defined: "+e.source),t=e.target&&e.target.$expr?r.eventExpression(e.target.$expr):r.get(e.target),i&&i.$expr&&(i.$params&&(c=r.parseParameters(i.$params)),i=r.handlerExpression(i.$expr)),r.update(e,a,t,i,c)},getState:function(e){var t=this,n={};if(e.signals){var r=n.signals={};Object.keys(t.signals).forEach((n=>{const s=t.signals[n];e.signals(n,s)&&(r[n]=s.value)}))}if(e.data){var s=n.data={};Object.keys(t.data).forEach((n=>{const r=t.data[n];e.data(n,r)&&(s[n]=r.input.value)}))}return t.subcontext&&!1!==e.recurse&&(n.subcontext=t.subcontext.map((t=>t.getState(e)))),n},setState:function(e){var t=this,n=t.dataflow,r=e.data,s=e.signals;Object.keys(s||{}).forEach((e=>{n.update(t.signals[e],s[e],y)})),Object.keys(r||{}).forEach((e=>{n.pulse(t.data[e].input,n.changeset().remove(f).insert(r[e]))})),(e.subcontext||[]).forEach(((e,n)=>{const r=t.subcontext[n];r&&r.setState(e)}))}};export{b as context};export default null;
//# sourceMappingURL=/sm/f8b38f37bbe898f25b7abfcb1de32d8cd03066a88d0e64b7c412210ec5e68705.map