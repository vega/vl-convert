/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/vega-hierarchy@5.1.0/build/vega-hierarchy.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Transform as e,isTuple as t,ingest as a,stableCompare as n,tupleid as r}from"/npm/vega-dataflow@6.1.0/+esm";import{inherits as i,error as s,array as o,one as d,hasOwnProperty as u,truthy as l}from"/npm/vega-util@2.1.0/+esm";import{hierarchy as m,pack as p,partition as c,stratify as f,treemap as y,tree as h,cluster as g,treemapBinary as b,treemapDice as k,treemapSlice as v,treemapSliceDice as z,treemapSquarify as D,treemapResquarify as q}from"/npm/d3-hierarchy@3.1.2/+esm";function x(e,t,a){const n={};return e.each((e=>{const r=e.data;a(r)&&(n[t(r)]=e)})),e.lookup=n,e}function O(t){e.call(this,null,t)}O.Definition={type:"Nest",metadata:{treesource:!0,changes:!0},params:[{name:"keys",type:"field",array:!0},{name:"generate",type:"boolean"}]};const T=e=>e.values;function R(){const e=[],t={entries:e=>n(a(e,0),0),key:a=>(e.push(a),t)};function a(t,n){if(n>=e.length)return t;const r=t.length,i=e[n++],s={},o={};let d,u,l,m=-1;for(;++m<r;)d=i(u=t[m])+"",(l=s[d])?l.push(u):s[d]=[u];for(d in s)o[d]=a(s[d],n);return o}function n(t,a){if(++a>e.length)return t;const r=[];for(const e in t)r.push({key:e,values:n(t[e],a)});return r}return t}function S(t){e.call(this,null,t)}i(O,e,{transform(e,n){n.source||s("Nest transform requires an upstream data source.");var i=e.generate,d=e.modified(),u=n.clone(),l=this.value;return(!l||d||n.changed())&&(l&&l.each((e=>{e.children&&t(e.data)&&u.rem.push(e.data)})),this.value=l=m({values:o(e.keys).reduce(((e,t)=>(e.key(t),e)),R()).entries(u.source)},T),i&&l.each((e=>{e.children&&(e=a(e.data),u.add.push(e),u.source.push(e))})),x(l,r,r)),u.source.root=l,u}});const E=(e,t)=>e.parent===t.parent?1:2;i(S,e,{transform(e,t){t.source&&t.source.root||s(this.constructor.name+" transform requires a backing tree data source.");const a=this.layout(e.method),r=this.fields,i=t.source.root,o=e.as||r;e.field?i.sum(e.field):i.count(),e.sort&&i.sort(n(e.sort,(e=>e.data))),function(e,t,a){for(let n,r=0,i=t.length;r<i;++r)n=t[r],n in a&&e[n](a[n])}(a,this.params,e),a.separation&&a.separation(!1!==e.separation?E:d);try{this.value=a(i)}catch(e){s(e)}return i.each((e=>function(e,t,a){const n=e.data,r=t.length-1;for(let i=0;i<r;++i)n[a[i]]=e[t[i]];n[a[r]]=e.children?e.children.length:0}(e,r,o))),t.reflow(e.modified()).modifies(o).modifies("leaf")}});const L=["x","y","r","depth","children"];function U(e){S.call(this,e)}U.Definition={type:"Pack",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"radius",type:"field",default:null},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:L.length,default:L}]},i(U,S,{layout:p,params:["radius","size","padding"],fields:L});const M=["x0","y0","x1","y1","depth","children"];function A(e){S.call(this,e)}function C(t){e.call(this,null,t)}A.Definition={type:"Partition",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"round",type:"boolean",default:!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:M.length,default:M}]},i(A,S,{layout:c,params:["size","round","padding"],fields:M}),C.Definition={type:"Stratify",metadata:{treesource:!0},params:[{name:"key",type:"field",required:!0},{name:"parentKey",type:"field",required:!0}]},i(C,e,{transform(e,t){t.source||s("Stratify transform requires an upstream data source.");let a=this.value;const n=e.modified(),r=t.fork(t.ALL).materialize(t.SOURCE),i=!a||n||t.changed(t.ADD_REM)||t.modified(e.key.fields)||t.modified(e.parentKey.fields);return r.source=r.source.slice(),i&&(a=r.source.length?x(f().id(e.key).parentId(e.parentKey)(r.source),e.key,l):x(f()([{}]),e.key,e.key)),r.source.root=this.value=a,r}});const I={tidy:h,cluster:g},K=["x","y","depth","children"];function N(e){S.call(this,e)}function _(t){e.call(this,[],t)}N.Definition={type:"Tree",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"tidy",values:["tidy","cluster"]},{name:"size",type:"number",array:!0,length:2},{name:"nodeSize",type:"number",array:!0,length:2},{name:"separation",type:"boolean",default:!0},{name:"as",type:"string",array:!0,length:K.length,default:K}]},i(N,S,{layout(e){const t=e||"tidy";if(u(I,t))return I[t]();s("Unrecognized Tree layout method: "+t)},params:["size","nodeSize"],fields:K}),_.Definition={type:"TreeLinks",metadata:{tree:!0,generates:!0,changes:!0},params:[]},i(_,e,{transform(e,t){const n=this.value,i=t.source&&t.source.root,o=t.fork(t.NO_SOURCE),d={};return i||s("TreeLinks transform requires a tree data source."),t.changed(t.ADD_REM)?(o.rem=n,t.visit(t.SOURCE,(e=>d[r(e)]=1)),i.each((e=>{const t=e.data,n=e.parent&&e.parent.data;n&&d[r(t)]&&d[r(n)]&&o.add.push(a({source:n,target:t}))})),this.value=o.add):t.changed(t.MOD)&&(t.visit(t.MOD,(e=>d[r(e)]=1)),n.forEach((e=>{(d[r(e.source)]||d[r(e.target)])&&o.mod.push(e)}))),o}});const w={binary:b,dice:k,slice:v,slicedice:z,squarify:D,resquarify:q},B=["x0","y0","x1","y1","depth","children"];function P(e){S.call(this,e)}P.Definition={type:"Treemap",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"squarify",values:["squarify","resquarify","binary","dice","slice","slicedice"]},{name:"padding",type:"number",default:0},{name:"paddingInner",type:"number",default:0},{name:"paddingOuter",type:"number",default:0},{name:"paddingTop",type:"number",default:0},{name:"paddingRight",type:"number",default:0},{name:"paddingBottom",type:"number",default:0},{name:"paddingLeft",type:"number",default:0},{name:"ratio",type:"number",default:1.618033988749895},{name:"round",type:"boolean",default:!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:B.length,default:B}]},i(P,S,{layout(){const e=y();return e.ratio=t=>{const a=e.tile();a.ratio&&e.tile(a.ratio(t))},e.method=t=>{u(w,t)?e.tile(w[t]):s("Unrecognized Treemap layout method: "+t)},e},params:["method","ratio","size","round","padding","paddingInner","paddingOuter","paddingTop","paddingRight","paddingBottom","paddingLeft"],fields:B});export{O as nest,U as pack,A as partition,C as stratify,N as tree,_ as treelinks,P as treemap};export default null;
//# sourceMappingURL=/sm/f38affcec59b4eb98017456595cd32421f731fd067aff2653e1d19eb064e75a4.map