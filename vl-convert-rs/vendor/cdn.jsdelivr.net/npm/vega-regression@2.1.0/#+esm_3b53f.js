/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/vega-regression@2.1.0/build/vega-regression.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{regressionLoess as e,sampleCurve as a,regressionConstant as r,regressionLinear as t,regressionLog as n,regressionExp as o,regressionPow as s,regressionQuad as i,regressionPoly as l}from"/npm/vega-statistics@2.0.0/+esm";import{Transform as u,ingest as d}from"/npm/vega-dataflow@6.1.0/+esm";import{inherits as m,accessorName as p,hasOwnProperty as f,error as h,extent as y}from"/npm/vega-util@2.1.0/+esm";function c(e,a){var r,t,n,o,s,i,l=[],u=function(e){return e(o)};if(null==a)l.push(e);else for(r={},t=0,n=e.length;t<n;++t)o=e[t],(i=r[s=a.map(u)])||(r[s]=i=[],i.dims=s,l.push(i)),i.push(o);return l}function g(e){u.call(this,null,e)}g.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},m(g,u,{transform(a,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||a.modified()){const n=c(r.materialize(r.SOURCE).source,a.groupby),o=(a.groupby||[]).map(p),s=o.length,i=a.as||[p(a.x),p(a.y)],l=[];n.forEach((r=>{e(r,a.x,a.y,a.bandwidth||.3).forEach((e=>{const a={};for(let e=0;e<s;++e)a[o[e]]=r.dims[e];a[i[0]]=e[0],a[i[1]]=e[1],l.push(d(a))}))})),this.value&&(t.rem=this.value),this.value=t.add=t.source=l}return t}});const v={constant:r,linear:t,log:n,exp:o,pow:s,quad:i,poly:l};function b(e){u.call(this,null,e)}b.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(v)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},m(b,u,{transform(e,r){const t=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const n=c(r.materialize(r.SOURCE).source,e.groupby),o=(e.groupby||[]).map(p),s=e.method||"linear",i=null==e.order?3:e.order,l=((e,a)=>"poly"===e?a:"quad"===e?2:1)(s,i),u=e.as||[p(e.x),p(e.y)],m=v[s],g=[];let b=e.extent;f(v,s)||h("Invalid regression method: "+s),null!=b&&"log"===s&&b[0]<=0&&(r.dataflow.warn("Ignoring extent with values <= 0 for log regression."),b=null),n.forEach((t=>{if(t.length<=l)return void r.dataflow.warn("Skipping regression with more parameters than data points.");const n=m(t,e.x,e.y,i);if(e.params)return void g.push(d({keys:t.dims,coef:n.coef,rSquared:n.rSquared}));const p=b||y(t,e.x),f=e=>{const a={};for(let e=0;e<o.length;++e)a[o[e]]=t.dims[e];a[u[0]]=e[0],a[u[1]]=e[1],g.push(d(a))};"linear"===s||"constant"===s?p.forEach((e=>f([e,n.predict(e)]))):a(n.predict,p,25,200).forEach(f)})),this.value&&(t.rem=this.value),this.value=t.add=t.source=g}return t}});export{g as loess,b as regression};export default null;
//# sourceMappingURL=/sm/975c523cd3438f6254909e79f6cfc37b2444f1e2f01f706bc84bbc0be9a57bb1.map